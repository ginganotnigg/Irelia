// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	irelia "irelia/api"
	"irelia/pkg/ent/interview"
	"irelia/pkg/ent/interviewfavorite"
	"irelia/pkg/ent/predicate"
	"irelia/pkg/ent/question"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeInterview         = "Interview"
	TypeInterviewFavorite = "InterviewFavorite"
	TypeQuestion          = "Question"
)

// InterviewMutation represents an operation that mutates the Interview nodes in the graph.
type InterviewMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	user_id                *uint64
	adduser_id             *int64
	position               *string
	experience             *string
	language               *string
	voice_id               *string
	speed                  *int32
	addspeed               *int32
	skills                 *[]string
	appendskills           []string
	skills_score           *[]string
	appendskills_score     []string
	skip_code              *bool
	total_questions        *int32
	addtotal_questions     *int32
	remaining_questions    *int32
	addremaining_questions *int32
	total_score            **irelia.TotalScore
	positive_feedback      *string
	actionable_feedback    *string
	final_comment          *string
	status                 *irelia.InterviewStatus
	addstatus              *irelia.InterviewStatus
	clearedFields          map[string]struct{}
	questions              map[int]struct{}
	removedquestions       map[int]struct{}
	clearedquestions       bool
	favorites              map[int]struct{}
	removedfavorites       map[int]struct{}
	clearedfavorites       bool
	done                   bool
	oldValue               func(context.Context) (*Interview, error)
	predicates             []predicate.Interview
}

var _ ent.Mutation = (*InterviewMutation)(nil)

// interviewOption allows management of the mutation configuration using functional options.
type interviewOption func(*InterviewMutation)

// newInterviewMutation creates new mutation for the Interview entity.
func newInterviewMutation(c config, op Op, opts ...interviewOption) *InterviewMutation {
	m := &InterviewMutation{
		config:        c,
		op:            op,
		typ:           TypeInterview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInterviewID sets the ID field of the mutation.
func withInterviewID(id string) interviewOption {
	return func(m *InterviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Interview
		)
		m.oldValue = func(ctx context.Context) (*Interview, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Interview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInterview sets the old Interview of the mutation.
func withInterview(node *Interview) interviewOption {
	return func(m *InterviewMutation) {
		m.oldValue = func(context.Context) (*Interview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InterviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InterviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Interview entities.
func (m *InterviewMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InterviewMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InterviewMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Interview.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InterviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InterviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InterviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InterviewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InterviewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InterviewMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *InterviewMutation) SetUserID(u uint64) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InterviewMutation) UserID() (r uint64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *InterviewMutation) AddUserID(u int64) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *InterviewMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InterviewMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetPosition sets the "position" field.
func (m *InterviewMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *InterviewMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *InterviewMutation) ResetPosition() {
	m.position = nil
}

// SetExperience sets the "experience" field.
func (m *InterviewMutation) SetExperience(s string) {
	m.experience = &s
}

// Experience returns the value of the "experience" field in the mutation.
func (m *InterviewMutation) Experience() (r string, exists bool) {
	v := m.experience
	if v == nil {
		return
	}
	return *v, true
}

// OldExperience returns the old "experience" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldExperience(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperience: %w", err)
	}
	return oldValue.Experience, nil
}

// ClearExperience clears the value of the "experience" field.
func (m *InterviewMutation) ClearExperience() {
	m.experience = nil
	m.clearedFields[interview.FieldExperience] = struct{}{}
}

// ExperienceCleared returns if the "experience" field was cleared in this mutation.
func (m *InterviewMutation) ExperienceCleared() bool {
	_, ok := m.clearedFields[interview.FieldExperience]
	return ok
}

// ResetExperience resets all changes to the "experience" field.
func (m *InterviewMutation) ResetExperience() {
	m.experience = nil
	delete(m.clearedFields, interview.FieldExperience)
}

// SetLanguage sets the "language" field.
func (m *InterviewMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *InterviewMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *InterviewMutation) ResetLanguage() {
	m.language = nil
}

// SetVoiceID sets the "voice_id" field.
func (m *InterviewMutation) SetVoiceID(s string) {
	m.voice_id = &s
}

// VoiceID returns the value of the "voice_id" field in the mutation.
func (m *InterviewMutation) VoiceID() (r string, exists bool) {
	v := m.voice_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVoiceID returns the old "voice_id" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldVoiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoiceID: %w", err)
	}
	return oldValue.VoiceID, nil
}

// ClearVoiceID clears the value of the "voice_id" field.
func (m *InterviewMutation) ClearVoiceID() {
	m.voice_id = nil
	m.clearedFields[interview.FieldVoiceID] = struct{}{}
}

// VoiceIDCleared returns if the "voice_id" field was cleared in this mutation.
func (m *InterviewMutation) VoiceIDCleared() bool {
	_, ok := m.clearedFields[interview.FieldVoiceID]
	return ok
}

// ResetVoiceID resets all changes to the "voice_id" field.
func (m *InterviewMutation) ResetVoiceID() {
	m.voice_id = nil
	delete(m.clearedFields, interview.FieldVoiceID)
}

// SetSpeed sets the "speed" field.
func (m *InterviewMutation) SetSpeed(i int32) {
	m.speed = &i
	m.addspeed = nil
}

// Speed returns the value of the "speed" field in the mutation.
func (m *InterviewMutation) Speed() (r int32, exists bool) {
	v := m.speed
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeed returns the old "speed" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldSpeed(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeed: %w", err)
	}
	return oldValue.Speed, nil
}

// AddSpeed adds i to the "speed" field.
func (m *InterviewMutation) AddSpeed(i int32) {
	if m.addspeed != nil {
		*m.addspeed += i
	} else {
		m.addspeed = &i
	}
}

// AddedSpeed returns the value that was added to the "speed" field in this mutation.
func (m *InterviewMutation) AddedSpeed() (r int32, exists bool) {
	v := m.addspeed
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpeed resets all changes to the "speed" field.
func (m *InterviewMutation) ResetSpeed() {
	m.speed = nil
	m.addspeed = nil
}

// SetSkills sets the "skills" field.
func (m *InterviewMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *InterviewMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *InterviewMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *InterviewMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ClearSkills clears the value of the "skills" field.
func (m *InterviewMutation) ClearSkills() {
	m.skills = nil
	m.appendskills = nil
	m.clearedFields[interview.FieldSkills] = struct{}{}
}

// SkillsCleared returns if the "skills" field was cleared in this mutation.
func (m *InterviewMutation) SkillsCleared() bool {
	_, ok := m.clearedFields[interview.FieldSkills]
	return ok
}

// ResetSkills resets all changes to the "skills" field.
func (m *InterviewMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
	delete(m.clearedFields, interview.FieldSkills)
}

// SetSkillsScore sets the "skills_score" field.
func (m *InterviewMutation) SetSkillsScore(s []string) {
	m.skills_score = &s
	m.appendskills_score = nil
}

// SkillsScore returns the value of the "skills_score" field in the mutation.
func (m *InterviewMutation) SkillsScore() (r []string, exists bool) {
	v := m.skills_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillsScore returns the old "skills_score" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldSkillsScore(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillsScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillsScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillsScore: %w", err)
	}
	return oldValue.SkillsScore, nil
}

// AppendSkillsScore adds s to the "skills_score" field.
func (m *InterviewMutation) AppendSkillsScore(s []string) {
	m.appendskills_score = append(m.appendskills_score, s...)
}

// AppendedSkillsScore returns the list of values that were appended to the "skills_score" field in this mutation.
func (m *InterviewMutation) AppendedSkillsScore() ([]string, bool) {
	if len(m.appendskills_score) == 0 {
		return nil, false
	}
	return m.appendskills_score, true
}

// ClearSkillsScore clears the value of the "skills_score" field.
func (m *InterviewMutation) ClearSkillsScore() {
	m.skills_score = nil
	m.appendskills_score = nil
	m.clearedFields[interview.FieldSkillsScore] = struct{}{}
}

// SkillsScoreCleared returns if the "skills_score" field was cleared in this mutation.
func (m *InterviewMutation) SkillsScoreCleared() bool {
	_, ok := m.clearedFields[interview.FieldSkillsScore]
	return ok
}

// ResetSkillsScore resets all changes to the "skills_score" field.
func (m *InterviewMutation) ResetSkillsScore() {
	m.skills_score = nil
	m.appendskills_score = nil
	delete(m.clearedFields, interview.FieldSkillsScore)
}

// SetSkipCode sets the "skip_code" field.
func (m *InterviewMutation) SetSkipCode(b bool) {
	m.skip_code = &b
}

// SkipCode returns the value of the "skip_code" field in the mutation.
func (m *InterviewMutation) SkipCode() (r bool, exists bool) {
	v := m.skip_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSkipCode returns the old "skip_code" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldSkipCode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkipCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkipCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkipCode: %w", err)
	}
	return oldValue.SkipCode, nil
}

// ResetSkipCode resets all changes to the "skip_code" field.
func (m *InterviewMutation) ResetSkipCode() {
	m.skip_code = nil
}

// SetTotalQuestions sets the "total_questions" field.
func (m *InterviewMutation) SetTotalQuestions(i int32) {
	m.total_questions = &i
	m.addtotal_questions = nil
}

// TotalQuestions returns the value of the "total_questions" field in the mutation.
func (m *InterviewMutation) TotalQuestions() (r int32, exists bool) {
	v := m.total_questions
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalQuestions returns the old "total_questions" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldTotalQuestions(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalQuestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalQuestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalQuestions: %w", err)
	}
	return oldValue.TotalQuestions, nil
}

// AddTotalQuestions adds i to the "total_questions" field.
func (m *InterviewMutation) AddTotalQuestions(i int32) {
	if m.addtotal_questions != nil {
		*m.addtotal_questions += i
	} else {
		m.addtotal_questions = &i
	}
}

// AddedTotalQuestions returns the value that was added to the "total_questions" field in this mutation.
func (m *InterviewMutation) AddedTotalQuestions() (r int32, exists bool) {
	v := m.addtotal_questions
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalQuestions resets all changes to the "total_questions" field.
func (m *InterviewMutation) ResetTotalQuestions() {
	m.total_questions = nil
	m.addtotal_questions = nil
}

// SetRemainingQuestions sets the "remaining_questions" field.
func (m *InterviewMutation) SetRemainingQuestions(i int32) {
	m.remaining_questions = &i
	m.addremaining_questions = nil
}

// RemainingQuestions returns the value of the "remaining_questions" field in the mutation.
func (m *InterviewMutation) RemainingQuestions() (r int32, exists bool) {
	v := m.remaining_questions
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingQuestions returns the old "remaining_questions" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldRemainingQuestions(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainingQuestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainingQuestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingQuestions: %w", err)
	}
	return oldValue.RemainingQuestions, nil
}

// AddRemainingQuestions adds i to the "remaining_questions" field.
func (m *InterviewMutation) AddRemainingQuestions(i int32) {
	if m.addremaining_questions != nil {
		*m.addremaining_questions += i
	} else {
		m.addremaining_questions = &i
	}
}

// AddedRemainingQuestions returns the value that was added to the "remaining_questions" field in this mutation.
func (m *InterviewMutation) AddedRemainingQuestions() (r int32, exists bool) {
	v := m.addremaining_questions
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainingQuestions resets all changes to the "remaining_questions" field.
func (m *InterviewMutation) ResetRemainingQuestions() {
	m.remaining_questions = nil
	m.addremaining_questions = nil
}

// SetTotalScore sets the "total_score" field.
func (m *InterviewMutation) SetTotalScore(is *irelia.TotalScore) {
	m.total_score = &is
}

// TotalScore returns the value of the "total_score" field in the mutation.
func (m *InterviewMutation) TotalScore() (r *irelia.TotalScore, exists bool) {
	v := m.total_score
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalScore returns the old "total_score" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldTotalScore(ctx context.Context) (v *irelia.TotalScore, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalScore: %w", err)
	}
	return oldValue.TotalScore, nil
}

// ClearTotalScore clears the value of the "total_score" field.
func (m *InterviewMutation) ClearTotalScore() {
	m.total_score = nil
	m.clearedFields[interview.FieldTotalScore] = struct{}{}
}

// TotalScoreCleared returns if the "total_score" field was cleared in this mutation.
func (m *InterviewMutation) TotalScoreCleared() bool {
	_, ok := m.clearedFields[interview.FieldTotalScore]
	return ok
}

// ResetTotalScore resets all changes to the "total_score" field.
func (m *InterviewMutation) ResetTotalScore() {
	m.total_score = nil
	delete(m.clearedFields, interview.FieldTotalScore)
}

// SetPositiveFeedback sets the "positive_feedback" field.
func (m *InterviewMutation) SetPositiveFeedback(s string) {
	m.positive_feedback = &s
}

// PositiveFeedback returns the value of the "positive_feedback" field in the mutation.
func (m *InterviewMutation) PositiveFeedback() (r string, exists bool) {
	v := m.positive_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldPositiveFeedback returns the old "positive_feedback" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldPositiveFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositiveFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositiveFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositiveFeedback: %w", err)
	}
	return oldValue.PositiveFeedback, nil
}

// ClearPositiveFeedback clears the value of the "positive_feedback" field.
func (m *InterviewMutation) ClearPositiveFeedback() {
	m.positive_feedback = nil
	m.clearedFields[interview.FieldPositiveFeedback] = struct{}{}
}

// PositiveFeedbackCleared returns if the "positive_feedback" field was cleared in this mutation.
func (m *InterviewMutation) PositiveFeedbackCleared() bool {
	_, ok := m.clearedFields[interview.FieldPositiveFeedback]
	return ok
}

// ResetPositiveFeedback resets all changes to the "positive_feedback" field.
func (m *InterviewMutation) ResetPositiveFeedback() {
	m.positive_feedback = nil
	delete(m.clearedFields, interview.FieldPositiveFeedback)
}

// SetActionableFeedback sets the "actionable_feedback" field.
func (m *InterviewMutation) SetActionableFeedback(s string) {
	m.actionable_feedback = &s
}

// ActionableFeedback returns the value of the "actionable_feedback" field in the mutation.
func (m *InterviewMutation) ActionableFeedback() (r string, exists bool) {
	v := m.actionable_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldActionableFeedback returns the old "actionable_feedback" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldActionableFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionableFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionableFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionableFeedback: %w", err)
	}
	return oldValue.ActionableFeedback, nil
}

// ClearActionableFeedback clears the value of the "actionable_feedback" field.
func (m *InterviewMutation) ClearActionableFeedback() {
	m.actionable_feedback = nil
	m.clearedFields[interview.FieldActionableFeedback] = struct{}{}
}

// ActionableFeedbackCleared returns if the "actionable_feedback" field was cleared in this mutation.
func (m *InterviewMutation) ActionableFeedbackCleared() bool {
	_, ok := m.clearedFields[interview.FieldActionableFeedback]
	return ok
}

// ResetActionableFeedback resets all changes to the "actionable_feedback" field.
func (m *InterviewMutation) ResetActionableFeedback() {
	m.actionable_feedback = nil
	delete(m.clearedFields, interview.FieldActionableFeedback)
}

// SetFinalComment sets the "final_comment" field.
func (m *InterviewMutation) SetFinalComment(s string) {
	m.final_comment = &s
}

// FinalComment returns the value of the "final_comment" field in the mutation.
func (m *InterviewMutation) FinalComment() (r string, exists bool) {
	v := m.final_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalComment returns the old "final_comment" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldFinalComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalComment: %w", err)
	}
	return oldValue.FinalComment, nil
}

// ClearFinalComment clears the value of the "final_comment" field.
func (m *InterviewMutation) ClearFinalComment() {
	m.final_comment = nil
	m.clearedFields[interview.FieldFinalComment] = struct{}{}
}

// FinalCommentCleared returns if the "final_comment" field was cleared in this mutation.
func (m *InterviewMutation) FinalCommentCleared() bool {
	_, ok := m.clearedFields[interview.FieldFinalComment]
	return ok
}

// ResetFinalComment resets all changes to the "final_comment" field.
func (m *InterviewMutation) ResetFinalComment() {
	m.final_comment = nil
	delete(m.clearedFields, interview.FieldFinalComment)
}

// SetStatus sets the "status" field.
func (m *InterviewMutation) SetStatus(is irelia.InterviewStatus) {
	m.status = &is
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *InterviewMutation) Status() (r irelia.InterviewStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldStatus(ctx context.Context) (v irelia.InterviewStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds is to the "status" field.
func (m *InterviewMutation) AddStatus(is irelia.InterviewStatus) {
	if m.addstatus != nil {
		*m.addstatus += is
	} else {
		m.addstatus = &is
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *InterviewMutation) AddedStatus() (r irelia.InterviewStatus, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *InterviewMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddQuestionIDs adds the "questions" edge to the Question entity by ids.
func (m *InterviewMutation) AddQuestionIDs(ids ...int) {
	if m.questions == nil {
		m.questions = make(map[int]struct{})
	}
	for i := range ids {
		m.questions[ids[i]] = struct{}{}
	}
}

// ClearQuestions clears the "questions" edge to the Question entity.
func (m *InterviewMutation) ClearQuestions() {
	m.clearedquestions = true
}

// QuestionsCleared reports if the "questions" edge to the Question entity was cleared.
func (m *InterviewMutation) QuestionsCleared() bool {
	return m.clearedquestions
}

// RemoveQuestionIDs removes the "questions" edge to the Question entity by IDs.
func (m *InterviewMutation) RemoveQuestionIDs(ids ...int) {
	if m.removedquestions == nil {
		m.removedquestions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.questions, ids[i])
		m.removedquestions[ids[i]] = struct{}{}
	}
}

// RemovedQuestions returns the removed IDs of the "questions" edge to the Question entity.
func (m *InterviewMutation) RemovedQuestionsIDs() (ids []int) {
	for id := range m.removedquestions {
		ids = append(ids, id)
	}
	return
}

// QuestionsIDs returns the "questions" edge IDs in the mutation.
func (m *InterviewMutation) QuestionsIDs() (ids []int) {
	for id := range m.questions {
		ids = append(ids, id)
	}
	return
}

// ResetQuestions resets all changes to the "questions" edge.
func (m *InterviewMutation) ResetQuestions() {
	m.questions = nil
	m.clearedquestions = false
	m.removedquestions = nil
}

// AddFavoriteIDs adds the "favorites" edge to the InterviewFavorite entity by ids.
func (m *InterviewMutation) AddFavoriteIDs(ids ...int) {
	if m.favorites == nil {
		m.favorites = make(map[int]struct{})
	}
	for i := range ids {
		m.favorites[ids[i]] = struct{}{}
	}
}

// ClearFavorites clears the "favorites" edge to the InterviewFavorite entity.
func (m *InterviewMutation) ClearFavorites() {
	m.clearedfavorites = true
}

// FavoritesCleared reports if the "favorites" edge to the InterviewFavorite entity was cleared.
func (m *InterviewMutation) FavoritesCleared() bool {
	return m.clearedfavorites
}

// RemoveFavoriteIDs removes the "favorites" edge to the InterviewFavorite entity by IDs.
func (m *InterviewMutation) RemoveFavoriteIDs(ids ...int) {
	if m.removedfavorites == nil {
		m.removedfavorites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favorites, ids[i])
		m.removedfavorites[ids[i]] = struct{}{}
	}
}

// RemovedFavorites returns the removed IDs of the "favorites" edge to the InterviewFavorite entity.
func (m *InterviewMutation) RemovedFavoritesIDs() (ids []int) {
	for id := range m.removedfavorites {
		ids = append(ids, id)
	}
	return
}

// FavoritesIDs returns the "favorites" edge IDs in the mutation.
func (m *InterviewMutation) FavoritesIDs() (ids []int) {
	for id := range m.favorites {
		ids = append(ids, id)
	}
	return
}

// ResetFavorites resets all changes to the "favorites" edge.
func (m *InterviewMutation) ResetFavorites() {
	m.favorites = nil
	m.clearedfavorites = false
	m.removedfavorites = nil
}

// Where appends a list predicates to the InterviewMutation builder.
func (m *InterviewMutation) Where(ps ...predicate.Interview) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InterviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InterviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Interview, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InterviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InterviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Interview).
func (m *InterviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InterviewMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, interview.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, interview.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, interview.FieldUserID)
	}
	if m.position != nil {
		fields = append(fields, interview.FieldPosition)
	}
	if m.experience != nil {
		fields = append(fields, interview.FieldExperience)
	}
	if m.language != nil {
		fields = append(fields, interview.FieldLanguage)
	}
	if m.voice_id != nil {
		fields = append(fields, interview.FieldVoiceID)
	}
	if m.speed != nil {
		fields = append(fields, interview.FieldSpeed)
	}
	if m.skills != nil {
		fields = append(fields, interview.FieldSkills)
	}
	if m.skills_score != nil {
		fields = append(fields, interview.FieldSkillsScore)
	}
	if m.skip_code != nil {
		fields = append(fields, interview.FieldSkipCode)
	}
	if m.total_questions != nil {
		fields = append(fields, interview.FieldTotalQuestions)
	}
	if m.remaining_questions != nil {
		fields = append(fields, interview.FieldRemainingQuestions)
	}
	if m.total_score != nil {
		fields = append(fields, interview.FieldTotalScore)
	}
	if m.positive_feedback != nil {
		fields = append(fields, interview.FieldPositiveFeedback)
	}
	if m.actionable_feedback != nil {
		fields = append(fields, interview.FieldActionableFeedback)
	}
	if m.final_comment != nil {
		fields = append(fields, interview.FieldFinalComment)
	}
	if m.status != nil {
		fields = append(fields, interview.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InterviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case interview.FieldCreatedAt:
		return m.CreatedAt()
	case interview.FieldUpdatedAt:
		return m.UpdatedAt()
	case interview.FieldUserID:
		return m.UserID()
	case interview.FieldPosition:
		return m.Position()
	case interview.FieldExperience:
		return m.Experience()
	case interview.FieldLanguage:
		return m.Language()
	case interview.FieldVoiceID:
		return m.VoiceID()
	case interview.FieldSpeed:
		return m.Speed()
	case interview.FieldSkills:
		return m.Skills()
	case interview.FieldSkillsScore:
		return m.SkillsScore()
	case interview.FieldSkipCode:
		return m.SkipCode()
	case interview.FieldTotalQuestions:
		return m.TotalQuestions()
	case interview.FieldRemainingQuestions:
		return m.RemainingQuestions()
	case interview.FieldTotalScore:
		return m.TotalScore()
	case interview.FieldPositiveFeedback:
		return m.PositiveFeedback()
	case interview.FieldActionableFeedback:
		return m.ActionableFeedback()
	case interview.FieldFinalComment:
		return m.FinalComment()
	case interview.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InterviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case interview.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case interview.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case interview.FieldUserID:
		return m.OldUserID(ctx)
	case interview.FieldPosition:
		return m.OldPosition(ctx)
	case interview.FieldExperience:
		return m.OldExperience(ctx)
	case interview.FieldLanguage:
		return m.OldLanguage(ctx)
	case interview.FieldVoiceID:
		return m.OldVoiceID(ctx)
	case interview.FieldSpeed:
		return m.OldSpeed(ctx)
	case interview.FieldSkills:
		return m.OldSkills(ctx)
	case interview.FieldSkillsScore:
		return m.OldSkillsScore(ctx)
	case interview.FieldSkipCode:
		return m.OldSkipCode(ctx)
	case interview.FieldTotalQuestions:
		return m.OldTotalQuestions(ctx)
	case interview.FieldRemainingQuestions:
		return m.OldRemainingQuestions(ctx)
	case interview.FieldTotalScore:
		return m.OldTotalScore(ctx)
	case interview.FieldPositiveFeedback:
		return m.OldPositiveFeedback(ctx)
	case interview.FieldActionableFeedback:
		return m.OldActionableFeedback(ctx)
	case interview.FieldFinalComment:
		return m.OldFinalComment(ctx)
	case interview.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Interview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InterviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case interview.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case interview.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case interview.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case interview.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case interview.FieldExperience:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperience(v)
		return nil
	case interview.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case interview.FieldVoiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoiceID(v)
		return nil
	case interview.FieldSpeed:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeed(v)
		return nil
	case interview.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case interview.FieldSkillsScore:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillsScore(v)
		return nil
	case interview.FieldSkipCode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkipCode(v)
		return nil
	case interview.FieldTotalQuestions:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalQuestions(v)
		return nil
	case interview.FieldRemainingQuestions:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingQuestions(v)
		return nil
	case interview.FieldTotalScore:
		v, ok := value.(*irelia.TotalScore)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalScore(v)
		return nil
	case interview.FieldPositiveFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositiveFeedback(v)
		return nil
	case interview.FieldActionableFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionableFeedback(v)
		return nil
	case interview.FieldFinalComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalComment(v)
		return nil
	case interview.FieldStatus:
		v, ok := value.(irelia.InterviewStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Interview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InterviewMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, interview.FieldUserID)
	}
	if m.addspeed != nil {
		fields = append(fields, interview.FieldSpeed)
	}
	if m.addtotal_questions != nil {
		fields = append(fields, interview.FieldTotalQuestions)
	}
	if m.addremaining_questions != nil {
		fields = append(fields, interview.FieldRemainingQuestions)
	}
	if m.addstatus != nil {
		fields = append(fields, interview.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InterviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case interview.FieldUserID:
		return m.AddedUserID()
	case interview.FieldSpeed:
		return m.AddedSpeed()
	case interview.FieldTotalQuestions:
		return m.AddedTotalQuestions()
	case interview.FieldRemainingQuestions:
		return m.AddedRemainingQuestions()
	case interview.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InterviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case interview.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case interview.FieldSpeed:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpeed(v)
		return nil
	case interview.FieldTotalQuestions:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalQuestions(v)
		return nil
	case interview.FieldRemainingQuestions:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainingQuestions(v)
		return nil
	case interview.FieldStatus:
		v, ok := value.(irelia.InterviewStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Interview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InterviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(interview.FieldExperience) {
		fields = append(fields, interview.FieldExperience)
	}
	if m.FieldCleared(interview.FieldVoiceID) {
		fields = append(fields, interview.FieldVoiceID)
	}
	if m.FieldCleared(interview.FieldSkills) {
		fields = append(fields, interview.FieldSkills)
	}
	if m.FieldCleared(interview.FieldSkillsScore) {
		fields = append(fields, interview.FieldSkillsScore)
	}
	if m.FieldCleared(interview.FieldTotalScore) {
		fields = append(fields, interview.FieldTotalScore)
	}
	if m.FieldCleared(interview.FieldPositiveFeedback) {
		fields = append(fields, interview.FieldPositiveFeedback)
	}
	if m.FieldCleared(interview.FieldActionableFeedback) {
		fields = append(fields, interview.FieldActionableFeedback)
	}
	if m.FieldCleared(interview.FieldFinalComment) {
		fields = append(fields, interview.FieldFinalComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InterviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InterviewMutation) ClearField(name string) error {
	switch name {
	case interview.FieldExperience:
		m.ClearExperience()
		return nil
	case interview.FieldVoiceID:
		m.ClearVoiceID()
		return nil
	case interview.FieldSkills:
		m.ClearSkills()
		return nil
	case interview.FieldSkillsScore:
		m.ClearSkillsScore()
		return nil
	case interview.FieldTotalScore:
		m.ClearTotalScore()
		return nil
	case interview.FieldPositiveFeedback:
		m.ClearPositiveFeedback()
		return nil
	case interview.FieldActionableFeedback:
		m.ClearActionableFeedback()
		return nil
	case interview.FieldFinalComment:
		m.ClearFinalComment()
		return nil
	}
	return fmt.Errorf("unknown Interview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InterviewMutation) ResetField(name string) error {
	switch name {
	case interview.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case interview.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case interview.FieldUserID:
		m.ResetUserID()
		return nil
	case interview.FieldPosition:
		m.ResetPosition()
		return nil
	case interview.FieldExperience:
		m.ResetExperience()
		return nil
	case interview.FieldLanguage:
		m.ResetLanguage()
		return nil
	case interview.FieldVoiceID:
		m.ResetVoiceID()
		return nil
	case interview.FieldSpeed:
		m.ResetSpeed()
		return nil
	case interview.FieldSkills:
		m.ResetSkills()
		return nil
	case interview.FieldSkillsScore:
		m.ResetSkillsScore()
		return nil
	case interview.FieldSkipCode:
		m.ResetSkipCode()
		return nil
	case interview.FieldTotalQuestions:
		m.ResetTotalQuestions()
		return nil
	case interview.FieldRemainingQuestions:
		m.ResetRemainingQuestions()
		return nil
	case interview.FieldTotalScore:
		m.ResetTotalScore()
		return nil
	case interview.FieldPositiveFeedback:
		m.ResetPositiveFeedback()
		return nil
	case interview.FieldActionableFeedback:
		m.ResetActionableFeedback()
		return nil
	case interview.FieldFinalComment:
		m.ResetFinalComment()
		return nil
	case interview.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Interview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InterviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.questions != nil {
		edges = append(edges, interview.EdgeQuestions)
	}
	if m.favorites != nil {
		edges = append(edges, interview.EdgeFavorites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InterviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case interview.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.questions))
		for id := range m.questions {
			ids = append(ids, id)
		}
		return ids
	case interview.EdgeFavorites:
		ids := make([]ent.Value, 0, len(m.favorites))
		for id := range m.favorites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InterviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedquestions != nil {
		edges = append(edges, interview.EdgeQuestions)
	}
	if m.removedfavorites != nil {
		edges = append(edges, interview.EdgeFavorites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InterviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case interview.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.removedquestions))
		for id := range m.removedquestions {
			ids = append(ids, id)
		}
		return ids
	case interview.EdgeFavorites:
		ids := make([]ent.Value, 0, len(m.removedfavorites))
		for id := range m.removedfavorites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InterviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedquestions {
		edges = append(edges, interview.EdgeQuestions)
	}
	if m.clearedfavorites {
		edges = append(edges, interview.EdgeFavorites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InterviewMutation) EdgeCleared(name string) bool {
	switch name {
	case interview.EdgeQuestions:
		return m.clearedquestions
	case interview.EdgeFavorites:
		return m.clearedfavorites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InterviewMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Interview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InterviewMutation) ResetEdge(name string) error {
	switch name {
	case interview.EdgeQuestions:
		m.ResetQuestions()
		return nil
	case interview.EdgeFavorites:
		m.ResetFavorites()
		return nil
	}
	return fmt.Errorf("unknown Interview edge %s", name)
}

// InterviewFavoriteMutation represents an operation that mutates the InterviewFavorite nodes in the graph.
type InterviewFavoriteMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	user_id          *uint64
	adduser_id       *int64
	clearedFields    map[string]struct{}
	interview        *string
	clearedinterview bool
	done             bool
	oldValue         func(context.Context) (*InterviewFavorite, error)
	predicates       []predicate.InterviewFavorite
}

var _ ent.Mutation = (*InterviewFavoriteMutation)(nil)

// interviewfavoriteOption allows management of the mutation configuration using functional options.
type interviewfavoriteOption func(*InterviewFavoriteMutation)

// newInterviewFavoriteMutation creates new mutation for the InterviewFavorite entity.
func newInterviewFavoriteMutation(c config, op Op, opts ...interviewfavoriteOption) *InterviewFavoriteMutation {
	m := &InterviewFavoriteMutation{
		config:        c,
		op:            op,
		typ:           TypeInterviewFavorite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInterviewFavoriteID sets the ID field of the mutation.
func withInterviewFavoriteID(id int) interviewfavoriteOption {
	return func(m *InterviewFavoriteMutation) {
		var (
			err   error
			once  sync.Once
			value *InterviewFavorite
		)
		m.oldValue = func(ctx context.Context) (*InterviewFavorite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InterviewFavorite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInterviewFavorite sets the old InterviewFavorite of the mutation.
func withInterviewFavorite(node *InterviewFavorite) interviewfavoriteOption {
	return func(m *InterviewFavoriteMutation) {
		m.oldValue = func(context.Context) (*InterviewFavorite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InterviewFavoriteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InterviewFavoriteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InterviewFavoriteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InterviewFavoriteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InterviewFavorite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InterviewFavoriteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InterviewFavoriteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InterviewFavorite entity.
// If the InterviewFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewFavoriteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InterviewFavoriteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InterviewFavoriteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InterviewFavoriteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InterviewFavorite entity.
// If the InterviewFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewFavoriteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InterviewFavoriteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *InterviewFavoriteMutation) SetUserID(u uint64) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InterviewFavoriteMutation) UserID() (r uint64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InterviewFavorite entity.
// If the InterviewFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewFavoriteMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *InterviewFavoriteMutation) AddUserID(u int64) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *InterviewFavoriteMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InterviewFavoriteMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetInterviewID sets the "interview_id" field.
func (m *InterviewFavoriteMutation) SetInterviewID(s string) {
	m.interview = &s
}

// InterviewID returns the value of the "interview_id" field in the mutation.
func (m *InterviewFavoriteMutation) InterviewID() (r string, exists bool) {
	v := m.interview
	if v == nil {
		return
	}
	return *v, true
}

// OldInterviewID returns the old "interview_id" field's value of the InterviewFavorite entity.
// If the InterviewFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewFavoriteMutation) OldInterviewID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterviewID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterviewID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterviewID: %w", err)
	}
	return oldValue.InterviewID, nil
}

// ResetInterviewID resets all changes to the "interview_id" field.
func (m *InterviewFavoriteMutation) ResetInterviewID() {
	m.interview = nil
}

// ClearInterview clears the "interview" edge to the Interview entity.
func (m *InterviewFavoriteMutation) ClearInterview() {
	m.clearedinterview = true
	m.clearedFields[interviewfavorite.FieldInterviewID] = struct{}{}
}

// InterviewCleared reports if the "interview" edge to the Interview entity was cleared.
func (m *InterviewFavoriteMutation) InterviewCleared() bool {
	return m.clearedinterview
}

// InterviewIDs returns the "interview" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InterviewID instead. It exists only for internal usage by the builders.
func (m *InterviewFavoriteMutation) InterviewIDs() (ids []string) {
	if id := m.interview; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInterview resets all changes to the "interview" edge.
func (m *InterviewFavoriteMutation) ResetInterview() {
	m.interview = nil
	m.clearedinterview = false
}

// Where appends a list predicates to the InterviewFavoriteMutation builder.
func (m *InterviewFavoriteMutation) Where(ps ...predicate.InterviewFavorite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InterviewFavoriteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InterviewFavoriteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InterviewFavorite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InterviewFavoriteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InterviewFavoriteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InterviewFavorite).
func (m *InterviewFavoriteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InterviewFavoriteMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, interviewfavorite.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, interviewfavorite.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, interviewfavorite.FieldUserID)
	}
	if m.interview != nil {
		fields = append(fields, interviewfavorite.FieldInterviewID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InterviewFavoriteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case interviewfavorite.FieldCreatedAt:
		return m.CreatedAt()
	case interviewfavorite.FieldUpdatedAt:
		return m.UpdatedAt()
	case interviewfavorite.FieldUserID:
		return m.UserID()
	case interviewfavorite.FieldInterviewID:
		return m.InterviewID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InterviewFavoriteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case interviewfavorite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case interviewfavorite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case interviewfavorite.FieldUserID:
		return m.OldUserID(ctx)
	case interviewfavorite.FieldInterviewID:
		return m.OldInterviewID(ctx)
	}
	return nil, fmt.Errorf("unknown InterviewFavorite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InterviewFavoriteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case interviewfavorite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case interviewfavorite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case interviewfavorite.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case interviewfavorite.FieldInterviewID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterviewID(v)
		return nil
	}
	return fmt.Errorf("unknown InterviewFavorite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InterviewFavoriteMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, interviewfavorite.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InterviewFavoriteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case interviewfavorite.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InterviewFavoriteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case interviewfavorite.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown InterviewFavorite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InterviewFavoriteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InterviewFavoriteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InterviewFavoriteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InterviewFavorite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InterviewFavoriteMutation) ResetField(name string) error {
	switch name {
	case interviewfavorite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case interviewfavorite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case interviewfavorite.FieldUserID:
		m.ResetUserID()
		return nil
	case interviewfavorite.FieldInterviewID:
		m.ResetInterviewID()
		return nil
	}
	return fmt.Errorf("unknown InterviewFavorite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InterviewFavoriteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.interview != nil {
		edges = append(edges, interviewfavorite.EdgeInterview)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InterviewFavoriteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case interviewfavorite.EdgeInterview:
		if id := m.interview; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InterviewFavoriteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InterviewFavoriteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InterviewFavoriteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinterview {
		edges = append(edges, interviewfavorite.EdgeInterview)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InterviewFavoriteMutation) EdgeCleared(name string) bool {
	switch name {
	case interviewfavorite.EdgeInterview:
		return m.clearedinterview
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InterviewFavoriteMutation) ClearEdge(name string) error {
	switch name {
	case interviewfavorite.EdgeInterview:
		m.ClearInterview()
		return nil
	}
	return fmt.Errorf("unknown InterviewFavorite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InterviewFavoriteMutation) ResetEdge(name string) error {
	switch name {
	case interviewfavorite.EdgeInterview:
		m.ResetInterview()
		return nil
	}
	return fmt.Errorf("unknown InterviewFavorite edge %s", name)
}

// QuestionMutation represents an operation that mutates the Question nodes in the graph.
type QuestionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	question_index    *int32
	addquestion_index *int32
	content           *string
	audio             *string
	lipsync           **irelia.LipSyncData
	answer            *string
	record_proof      *string
	comment           *string
	score             *string
	status            *irelia.QuestionStatus
	addstatus         *irelia.QuestionStatus
	clearedFields     map[string]struct{}
	interview         *string
	clearedinterview  bool
	done              bool
	oldValue          func(context.Context) (*Question, error)
	predicates        []predicate.Question
}

var _ ent.Mutation = (*QuestionMutation)(nil)

// questionOption allows management of the mutation configuration using functional options.
type questionOption func(*QuestionMutation)

// newQuestionMutation creates new mutation for the Question entity.
func newQuestionMutation(c config, op Op, opts ...questionOption) *QuestionMutation {
	m := &QuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuestionID sets the ID field of the mutation.
func withQuestionID(id int) questionOption {
	return func(m *QuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *Question
		)
		m.oldValue = func(ctx context.Context) (*Question, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Question.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuestion sets the old Question of the mutation.
func withQuestion(node *Question) questionOption {
	return func(m *QuestionMutation) {
		m.oldValue = func(context.Context) (*Question, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuestionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QuestionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Question.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *QuestionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *QuestionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *QuestionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *QuestionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *QuestionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *QuestionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetInterviewID sets the "interview_id" field.
func (m *QuestionMutation) SetInterviewID(s string) {
	m.interview = &s
}

// InterviewID returns the value of the "interview_id" field in the mutation.
func (m *QuestionMutation) InterviewID() (r string, exists bool) {
	v := m.interview
	if v == nil {
		return
	}
	return *v, true
}

// OldInterviewID returns the old "interview_id" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldInterviewID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterviewID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterviewID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterviewID: %w", err)
	}
	return oldValue.InterviewID, nil
}

// ResetInterviewID resets all changes to the "interview_id" field.
func (m *QuestionMutation) ResetInterviewID() {
	m.interview = nil
}

// SetQuestionIndex sets the "question_index" field.
func (m *QuestionMutation) SetQuestionIndex(i int32) {
	m.question_index = &i
	m.addquestion_index = nil
}

// QuestionIndex returns the value of the "question_index" field in the mutation.
func (m *QuestionMutation) QuestionIndex() (r int32, exists bool) {
	v := m.question_index
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionIndex returns the old "question_index" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldQuestionIndex(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionIndex: %w", err)
	}
	return oldValue.QuestionIndex, nil
}

// AddQuestionIndex adds i to the "question_index" field.
func (m *QuestionMutation) AddQuestionIndex(i int32) {
	if m.addquestion_index != nil {
		*m.addquestion_index += i
	} else {
		m.addquestion_index = &i
	}
}

// AddedQuestionIndex returns the value that was added to the "question_index" field in this mutation.
func (m *QuestionMutation) AddedQuestionIndex() (r int32, exists bool) {
	v := m.addquestion_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionIndex resets all changes to the "question_index" field.
func (m *QuestionMutation) ResetQuestionIndex() {
	m.question_index = nil
	m.addquestion_index = nil
}

// SetContent sets the "content" field.
func (m *QuestionMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *QuestionMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *QuestionMutation) ResetContent() {
	m.content = nil
}

// SetAudio sets the "audio" field.
func (m *QuestionMutation) SetAudio(s string) {
	m.audio = &s
}

// Audio returns the value of the "audio" field in the mutation.
func (m *QuestionMutation) Audio() (r string, exists bool) {
	v := m.audio
	if v == nil {
		return
	}
	return *v, true
}

// OldAudio returns the old "audio" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldAudio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudio: %w", err)
	}
	return oldValue.Audio, nil
}

// ClearAudio clears the value of the "audio" field.
func (m *QuestionMutation) ClearAudio() {
	m.audio = nil
	m.clearedFields[question.FieldAudio] = struct{}{}
}

// AudioCleared returns if the "audio" field was cleared in this mutation.
func (m *QuestionMutation) AudioCleared() bool {
	_, ok := m.clearedFields[question.FieldAudio]
	return ok
}

// ResetAudio resets all changes to the "audio" field.
func (m *QuestionMutation) ResetAudio() {
	m.audio = nil
	delete(m.clearedFields, question.FieldAudio)
}

// SetLipsync sets the "lipsync" field.
func (m *QuestionMutation) SetLipsync(isd *irelia.LipSyncData) {
	m.lipsync = &isd
}

// Lipsync returns the value of the "lipsync" field in the mutation.
func (m *QuestionMutation) Lipsync() (r *irelia.LipSyncData, exists bool) {
	v := m.lipsync
	if v == nil {
		return
	}
	return *v, true
}

// OldLipsync returns the old "lipsync" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldLipsync(ctx context.Context) (v *irelia.LipSyncData, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLipsync is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLipsync requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLipsync: %w", err)
	}
	return oldValue.Lipsync, nil
}

// ClearLipsync clears the value of the "lipsync" field.
func (m *QuestionMutation) ClearLipsync() {
	m.lipsync = nil
	m.clearedFields[question.FieldLipsync] = struct{}{}
}

// LipsyncCleared returns if the "lipsync" field was cleared in this mutation.
func (m *QuestionMutation) LipsyncCleared() bool {
	_, ok := m.clearedFields[question.FieldLipsync]
	return ok
}

// ResetLipsync resets all changes to the "lipsync" field.
func (m *QuestionMutation) ResetLipsync() {
	m.lipsync = nil
	delete(m.clearedFields, question.FieldLipsync)
}

// SetAnswer sets the "answer" field.
func (m *QuestionMutation) SetAnswer(s string) {
	m.answer = &s
}

// Answer returns the value of the "answer" field in the mutation.
func (m *QuestionMutation) Answer() (r string, exists bool) {
	v := m.answer
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswer returns the old "answer" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswer: %w", err)
	}
	return oldValue.Answer, nil
}

// ClearAnswer clears the value of the "answer" field.
func (m *QuestionMutation) ClearAnswer() {
	m.answer = nil
	m.clearedFields[question.FieldAnswer] = struct{}{}
}

// AnswerCleared returns if the "answer" field was cleared in this mutation.
func (m *QuestionMutation) AnswerCleared() bool {
	_, ok := m.clearedFields[question.FieldAnswer]
	return ok
}

// ResetAnswer resets all changes to the "answer" field.
func (m *QuestionMutation) ResetAnswer() {
	m.answer = nil
	delete(m.clearedFields, question.FieldAnswer)
}

// SetRecordProof sets the "record_proof" field.
func (m *QuestionMutation) SetRecordProof(s string) {
	m.record_proof = &s
}

// RecordProof returns the value of the "record_proof" field in the mutation.
func (m *QuestionMutation) RecordProof() (r string, exists bool) {
	v := m.record_proof
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordProof returns the old "record_proof" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldRecordProof(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordProof is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordProof requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordProof: %w", err)
	}
	return oldValue.RecordProof, nil
}

// ClearRecordProof clears the value of the "record_proof" field.
func (m *QuestionMutation) ClearRecordProof() {
	m.record_proof = nil
	m.clearedFields[question.FieldRecordProof] = struct{}{}
}

// RecordProofCleared returns if the "record_proof" field was cleared in this mutation.
func (m *QuestionMutation) RecordProofCleared() bool {
	_, ok := m.clearedFields[question.FieldRecordProof]
	return ok
}

// ResetRecordProof resets all changes to the "record_proof" field.
func (m *QuestionMutation) ResetRecordProof() {
	m.record_proof = nil
	delete(m.clearedFields, question.FieldRecordProof)
}

// SetComment sets the "comment" field.
func (m *QuestionMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *QuestionMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *QuestionMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[question.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *QuestionMutation) CommentCleared() bool {
	_, ok := m.clearedFields[question.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *QuestionMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, question.FieldComment)
}

// SetScore sets the "score" field.
func (m *QuestionMutation) SetScore(s string) {
	m.score = &s
}

// Score returns the value of the "score" field in the mutation.
func (m *QuestionMutation) Score() (r string, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldScore(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// ClearScore clears the value of the "score" field.
func (m *QuestionMutation) ClearScore() {
	m.score = nil
	m.clearedFields[question.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *QuestionMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[question.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *QuestionMutation) ResetScore() {
	m.score = nil
	delete(m.clearedFields, question.FieldScore)
}

// SetStatus sets the "status" field.
func (m *QuestionMutation) SetStatus(is irelia.QuestionStatus) {
	m.status = &is
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *QuestionMutation) Status() (r irelia.QuestionStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldStatus(ctx context.Context) (v irelia.QuestionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds is to the "status" field.
func (m *QuestionMutation) AddStatus(is irelia.QuestionStatus) {
	if m.addstatus != nil {
		*m.addstatus += is
	} else {
		m.addstatus = &is
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *QuestionMutation) AddedStatus() (r irelia.QuestionStatus, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *QuestionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// ClearInterview clears the "interview" edge to the Interview entity.
func (m *QuestionMutation) ClearInterview() {
	m.clearedinterview = true
	m.clearedFields[question.FieldInterviewID] = struct{}{}
}

// InterviewCleared reports if the "interview" edge to the Interview entity was cleared.
func (m *QuestionMutation) InterviewCleared() bool {
	return m.clearedinterview
}

// InterviewIDs returns the "interview" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InterviewID instead. It exists only for internal usage by the builders.
func (m *QuestionMutation) InterviewIDs() (ids []string) {
	if id := m.interview; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInterview resets all changes to the "interview" edge.
func (m *QuestionMutation) ResetInterview() {
	m.interview = nil
	m.clearedinterview = false
}

// Where appends a list predicates to the QuestionMutation builder.
func (m *QuestionMutation) Where(ps ...predicate.Question) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QuestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QuestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Question, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QuestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QuestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Question).
func (m *QuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuestionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, question.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, question.FieldUpdatedAt)
	}
	if m.interview != nil {
		fields = append(fields, question.FieldInterviewID)
	}
	if m.question_index != nil {
		fields = append(fields, question.FieldQuestionIndex)
	}
	if m.content != nil {
		fields = append(fields, question.FieldContent)
	}
	if m.audio != nil {
		fields = append(fields, question.FieldAudio)
	}
	if m.lipsync != nil {
		fields = append(fields, question.FieldLipsync)
	}
	if m.answer != nil {
		fields = append(fields, question.FieldAnswer)
	}
	if m.record_proof != nil {
		fields = append(fields, question.FieldRecordProof)
	}
	if m.comment != nil {
		fields = append(fields, question.FieldComment)
	}
	if m.score != nil {
		fields = append(fields, question.FieldScore)
	}
	if m.status != nil {
		fields = append(fields, question.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case question.FieldCreatedAt:
		return m.CreatedAt()
	case question.FieldUpdatedAt:
		return m.UpdatedAt()
	case question.FieldInterviewID:
		return m.InterviewID()
	case question.FieldQuestionIndex:
		return m.QuestionIndex()
	case question.FieldContent:
		return m.Content()
	case question.FieldAudio:
		return m.Audio()
	case question.FieldLipsync:
		return m.Lipsync()
	case question.FieldAnswer:
		return m.Answer()
	case question.FieldRecordProof:
		return m.RecordProof()
	case question.FieldComment:
		return m.Comment()
	case question.FieldScore:
		return m.Score()
	case question.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case question.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case question.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case question.FieldInterviewID:
		return m.OldInterviewID(ctx)
	case question.FieldQuestionIndex:
		return m.OldQuestionIndex(ctx)
	case question.FieldContent:
		return m.OldContent(ctx)
	case question.FieldAudio:
		return m.OldAudio(ctx)
	case question.FieldLipsync:
		return m.OldLipsync(ctx)
	case question.FieldAnswer:
		return m.OldAnswer(ctx)
	case question.FieldRecordProof:
		return m.OldRecordProof(ctx)
	case question.FieldComment:
		return m.OldComment(ctx)
	case question.FieldScore:
		return m.OldScore(ctx)
	case question.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Question field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case question.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case question.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case question.FieldInterviewID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterviewID(v)
		return nil
	case question.FieldQuestionIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionIndex(v)
		return nil
	case question.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case question.FieldAudio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudio(v)
		return nil
	case question.FieldLipsync:
		v, ok := value.(*irelia.LipSyncData)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLipsync(v)
		return nil
	case question.FieldAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswer(v)
		return nil
	case question.FieldRecordProof:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordProof(v)
		return nil
	case question.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case question.FieldScore:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case question.FieldStatus:
		v, ok := value.(irelia.QuestionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuestionMutation) AddedFields() []string {
	var fields []string
	if m.addquestion_index != nil {
		fields = append(fields, question.FieldQuestionIndex)
	}
	if m.addstatus != nil {
		fields = append(fields, question.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuestionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case question.FieldQuestionIndex:
		return m.AddedQuestionIndex()
	case question.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case question.FieldQuestionIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionIndex(v)
		return nil
	case question.FieldStatus:
		v, ok := value.(irelia.QuestionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Question numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuestionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(question.FieldAudio) {
		fields = append(fields, question.FieldAudio)
	}
	if m.FieldCleared(question.FieldLipsync) {
		fields = append(fields, question.FieldLipsync)
	}
	if m.FieldCleared(question.FieldAnswer) {
		fields = append(fields, question.FieldAnswer)
	}
	if m.FieldCleared(question.FieldRecordProof) {
		fields = append(fields, question.FieldRecordProof)
	}
	if m.FieldCleared(question.FieldComment) {
		fields = append(fields, question.FieldComment)
	}
	if m.FieldCleared(question.FieldScore) {
		fields = append(fields, question.FieldScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuestionMutation) ClearField(name string) error {
	switch name {
	case question.FieldAudio:
		m.ClearAudio()
		return nil
	case question.FieldLipsync:
		m.ClearLipsync()
		return nil
	case question.FieldAnswer:
		m.ClearAnswer()
		return nil
	case question.FieldRecordProof:
		m.ClearRecordProof()
		return nil
	case question.FieldComment:
		m.ClearComment()
		return nil
	case question.FieldScore:
		m.ClearScore()
		return nil
	}
	return fmt.Errorf("unknown Question nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuestionMutation) ResetField(name string) error {
	switch name {
	case question.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case question.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case question.FieldInterviewID:
		m.ResetInterviewID()
		return nil
	case question.FieldQuestionIndex:
		m.ResetQuestionIndex()
		return nil
	case question.FieldContent:
		m.ResetContent()
		return nil
	case question.FieldAudio:
		m.ResetAudio()
		return nil
	case question.FieldLipsync:
		m.ResetLipsync()
		return nil
	case question.FieldAnswer:
		m.ResetAnswer()
		return nil
	case question.FieldRecordProof:
		m.ResetRecordProof()
		return nil
	case question.FieldComment:
		m.ResetComment()
		return nil
	case question.FieldScore:
		m.ResetScore()
		return nil
	case question.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.interview != nil {
		edges = append(edges, question.EdgeInterview)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case question.EdgeInterview:
		if id := m.interview; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuestionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinterview {
		edges = append(edges, question.EdgeInterview)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case question.EdgeInterview:
		return m.clearedinterview
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuestionMutation) ClearEdge(name string) error {
	switch name {
	case question.EdgeInterview:
		m.ClearInterview()
		return nil
	}
	return fmt.Errorf("unknown Question unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuestionMutation) ResetEdge(name string) error {
	switch name {
	case question.EdgeInterview:
		m.ResetInterview()
		return nil
	}
	return fmt.Errorf("unknown Question edge %s", name)
}
