package features

import (
	"context"
	"crypto/md5"
	"fmt"
	"math/rand"
	"strings"
	"sync/atomic"
	"time"

	"github.com/spf13/viper"
	"go.uber.org/zap"
	"google.golang.org/protobuf/encoding/protojson"

	pb "irelia/api"
	chk "irelia/internal/utils/checker"
	"irelia/pkg/ent"
)

/*
* SERVICE FUNCTIONS
 */

func (s *Irelia) callDariusForGenerate(ctx context.Context, userID uint64, req *pb.NextQuestionRequest) (*pb.NextQuestionResponse, error) {
    // Log the request for debugging
    s.logger.Info("Sending request to Darius for question generation", zap.Any("request", req))

    // Call the Darius service
    return s.dariusClient.Generate(ctx, fmt.Sprintf("%d", userID), req)
}

func (s *Irelia) callDariusForScore(ctx context.Context, userID uint64, req *pb.ScoreInterviewRequest) (*pb.ScoreInterviewResponse, error) {
    // Log the request for debugging
    s.logger.Info("Sending request to Darius for scoring", zap.Any("request", req))

    // Call the Darius service
    return s.dariusClient.Score(ctx, fmt.Sprintf("%d", userID), req)
}

func (s *Irelia) callKarmaForLipSync(ctx context.Context, req *pb.LipSyncRequest) (*pb.LipSyncResponse, error) {
    // Log the request for debugging
    s.logger.Info("Sending request to Karma for lip-sync generation", zap.Any("request", req))

    // Call the Karma service
    return s.karmaClient.LipSync(ctx, req)
}

func (s *Irelia) callKarmaForScore(ctx context.Context, req *pb.ScoreFluencyRequest) (*pb.ScoreFluencyResponse, error) {
    // Log the request for debugging
    s.logger.Info("Sending request to Karma for fluency scoring", zap.Any("request", req))

    // Call the Karma service
    return s.karmaClient.Score(ctx, req)
}

// Generates the next question using Darius and saves it in the database
func (s *Irelia) prepareContent(ctx context.Context, userID uint64, interviewID string, submissions []*pb.QaPair, remainingQuestions int32, questionIndex int32) ([]*ent.Question, error) {
	// Retrieve the interview context
	interviewContext, err := s.repo.Interview.GetContext(ctx, interviewID)
	if err != nil {
		s.logger.Error("Failed to retrieve interview context", zap.String("interviewId", interviewID), zap.Error(err))
		return nil, fmt.Errorf("failed to retrieve interview context: %v", err)
	}

	// Provide default values for empty fields in the context
	if interviewContext.Position == "" {
		interviewContext.Position = "General"
	}
	if interviewContext.Experience == "" {
		interviewContext.Experience = "General"
	}
	if interviewContext.Language == "" {
		interviewContext.Language = "English"
	}
	if len(interviewContext.Skills) == 0 {
		interviewContext.Skills = []string{"English skills"}
	}

	// Prepare the Darius request
	dariusReq := &pb.NextQuestionRequest{
		InterviewId:        interviewID,
		Submissions:        submissions,
		RemainingQuestions: remainingQuestions,
		Context: &pb.Context{
			Position:       interviewContext.Position,
			Experience:     interviewContext.Experience,
			Language:       interviewContext.Language,
			Skills:         interviewContext.Skills,
			TotalQuestions: interviewContext.TotalQuestions,
			SkipCode:       interviewContext.SkipCode,
		},
	}

	var dariusResp *pb.NextQuestionResponse

	dariusResp, err = s.callDariusForGenerate(context.Background(), userID, dariusReq)
	if err != nil {
		s.logger.Error("Failed to generate questions", zap.String("interviewId", interviewID))
		return nil, fmt.Errorf("failed to generate questions: %v", err)
	}

	if len(dariusResp.Questions) == 0 {
		s.logger.Error("No questions generated by Darius", zap.String("interviewId", interviewID))
		return nil, fmt.Errorf("no next question generated")
	}

	// Save the generated question(s) in the database
    questions := []*ent.Question{}
	for i, content := range dariusResp.Questions {
		index := questionIndex + int32(i)
		if index > interviewContext.TotalQuestions {
			break
		}
		question := &ent.Question{
			QuestionIndex: index,
			InterviewID:   interviewID,
			Content:       content,
		}
		questions = append(questions, question)
	}

	return questions, nil
}

// Prepare lip-sync data for a question synchronously
func (s *Irelia) prepareLipSync(ctx context.Context, question *ent.Question, interview *ent.Interview, isOutro bool) (*ent.Question, error) {
    if question == nil {
        s.logger.Error("Question is nil, cannot prepare lip sync", zap.String("interviewId", interview.ID))
        return nil, fmt.Errorf("question is nil, cannot prepare lip sync")
    }

    s.logger.Info("Preparing lip sync", zap.String("interviewId", interview.ID), zap.String("content", question.Content))

    // Prepare the full string for lip-sync
    var fullString string
    var cacheKind string
    if isOutro {
        fullString = question.Content
        cacheKind = "outro"
    } else if question.QuestionIndex == 1 {
        fullString = s.addTransitionsToQuestion(question, interview.VoiceID, interview.Language)
        cacheKind = "intro"
    } else {
        fullString = s.addTransitionsToQuestion(question, interview.VoiceID, interview.Language)
        cacheKind = ""
    }

    // Only cache for intro, position, outro
    var cacheKey string
    if cacheKind != "" && s.redis != nil {
        cacheKey = lipSyncCacheKey(cacheKind, interview.VoiceID, interview.Language, fullString, interview.Speed)
        // Try to get from cache
        val, err := s.redis.Get(ctx, cacheKey)
        if err == nil && val != nil {
            var cachedResp pb.LipSyncResponse
            if err := protojson.Unmarshal([]byte(val), &cachedResp); err == nil {
                question.Audio = cachedResp.Audio
                question.Lipsync = cachedResp.Lipsync
                return question, nil
            }
        }
    }

    // Call the Karma service to generate lip-sync data
    karmaReq := &pb.LipSyncRequest{
        InterviewId: interview.ID,
        Content:     fullString,
        VoiceId:     interview.VoiceID,
        Speed:       interview.Speed,
    }

    karmaResp, err := s.callKarmaForLipSync(ctx, karmaReq)
    if err != nil {
        return nil, fmt.Errorf("failed to generate lip sync: %v", err)
    }

    // Update the question with the generated lip-sync data
    question.Audio = karmaResp.Audio
    question.Lipsync = karmaResp.Lipsync

    // Save to cache if intro/position/outro
    if cacheKind != "" && s.redis != nil {
        s.redis.Set(ctx, cacheKey, karmaResp, 1*time.Hour)
		s.logger.Info("Cached lip sync data", zap.String("cacheKey", cacheKey))
    }

    return question, nil
}

func (s *Irelia) prepareQuestionSafe(job QuestionPreparationJob) {
	jobKey := fmt.Sprintf("%s:%d", job.InterviewID, job.NextQuestionID)

	// Check if already in progress with better logging
	s.preparationMutex.Lock()
	if s.preparationStatus[job.InterviewID] == nil {
		s.preparationStatus[job.InterviewID] = make(map[int32]bool)
	}
	if s.preparationStatus[job.InterviewID][job.NextQuestionID] {
		s.preparationMutex.Unlock()
		s.logger.Info("Question preparation already in progress, skipping", zap.String("jobKey", jobKey),
			zap.String("interviewID", job.InterviewID),
			zap.Int32("questionID", job.NextQuestionID))
		return
	}
	s.preparationStatus[job.InterviewID][job.NextQuestionID] = true
	s.preparationMutex.Unlock()

	s.logger.Info("Starting question preparation", zap.String("jobKey", jobKey),
		zap.String("interviewID", job.InterviewID),
		zap.Int32("questionID", job.NextQuestionID),
		zap.Uint64("userID", job.UserID))

	// Cleanup status when done
	defer func() {
		s.preparationMutex.Lock()
		delete(s.preparationStatus[job.InterviewID], job.NextQuestionID)
		if len(s.preparationStatus[job.InterviewID]) == 0 {
			delete(s.preparationStatus, job.InterviewID)
		}
		s.preparationMutex.Unlock()

		s.logger.Info("Finished question preparation cleanup", zap.String("jobKey", jobKey))
	}()

	// Add timeout context for the preparation
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	if err := s.prepareQuestion(ctx, job); err != nil {
		s.logger.Error("Question preparation failed", zap.String("jobKey", jobKey),
			zap.Error(err))
	} else {
		s.logger.Info("Question preparation completed successfully", zap.String("jobKey", jobKey))
	}
}

func (s *Irelia) prepareQuestion(ctx context.Context, job QuestionPreparationJob) error {
	// Check if question already exists
	exists, err := s.repo.Question.Exists(ctx, job.InterviewID, job.NextQuestionID)
	if err != nil && !ent.IsNotFound(err) {
		s.logger.Error("Failed to check if question exists", zap.String("interviewID", job.InterviewID),
			zap.Int32("questionID", job.NextQuestionID),
			zap.Error(err))
		return fmt.Errorf("failed to check question existence: %w", err)
	}
	if exists {
		s.logger.Info("Question already exists, skipping generation", zap.String("interviewID", job.InterviewID),
			zap.Int32("questionID", job.NextQuestionID))
		return nil
	}
	
	questions := job.Questions
	if len(questions) == 0 {
		s.logger.Debug("No pre-prepared questions, generating from context", zap.String("interviewID", job.InterviewID),
			zap.Int32("questionID", job.NextQuestionID))

		submissions, err := s.repo.Question.GetQaPair(ctx, job.InterviewID, viper.GetInt("context_qa_length"))
		if err != nil && !ent.IsNotFound(err) {
			s.logger.Error("Failed to retrieve submissions for Darius", zap.String("interviewID", job.InterviewID),
				zap.Error(err))
			return fmt.Errorf("failed to retrieve submissions: %w", err)
		}

		s.logger.Debug("Retrieved submissions for question generation", zap.String("interviewID", job.InterviewID),
			zap.Int("submissionCount", len(submissions)))

		questions, err = s.prepareContent(ctx, job.UserID, job.InterviewID, submissions,
			job.Interview.TotalQuestions-job.NextQuestionID+1, job.NextQuestionID)
		if err != nil {
			s.logger.Error("Failed to generate questions from content", zap.String("interviewID", job.InterviewID),
				zap.Error(err))
			return fmt.Errorf("failed to generate questions: %w", err)
		}

		s.logger.Debug("Generated questions from content", zap.String("interviewID", job.InterviewID),
			zap.Int("questionCount", len(questions)))
	} else {
		s.logger.Debug("Using pre-prepared questions", zap.String("interviewID", job.InterviewID),
			zap.Int("questionCount", len(questions)))
	}

	// Prepare lip sync for each question
	for i, question := range questions {
		if job.NextQuestionID+int32(i) > job.Interview.TotalQuestions {
			break
		}

		s.logger.Debug("Preparing lip sync for question", zap.String("interviewID", job.InterviewID),
			zap.Int32("questionID", job.NextQuestionID+int32(i)))

		var err error
		questions[i], err = s.prepareLipSync(ctx, question, job.Interview, false)
		if err != nil {
			s.logger.Error("Failed to prepare lip sync for question", zap.String("interviewID", job.InterviewID),
				zap.Int32("questionID", job.NextQuestionID+int32(i)),
				zap.Error(err))
			continue
		}
		if err := s.repo.Question.Create(ctx, job.UserID, question); err != nil {
			if ent.IsConstraintError(err) {
				s.logger.Warn("Duplicate question detected, skipping creation",
					zap.String("interviewID", job.InterviewID),
					zap.Int32("questionID", job.NextQuestionID+int32(i)))
				continue
			}
			s.logger.Error("Failed to save questions", zap.String("interviewID", job.InterviewID),
				zap.Int32("questionID", job.NextQuestionID+int32(i)),
				zap.Error(err))
			continue
		}
	}

	s.logger.Info("Successfully prepared and saved questions", zap.String("interviewID", job.InterviewID),
		zap.Int32("startingQuestionID", job.NextQuestionID),
		zap.Int("questionCount", len(questions)))

	return nil
}

func (s *Irelia) ensureQuestionWorkerPool() {
    if atomic.LoadInt64(&s.questionWorkerPool.activeWorkers) == 0 {
        s.logger.Warn("All question workers have exited, restarting worker pool")
        s.questionWorkerPool.Start(s)
    }
}

func (s *Irelia) getUserID(ctx context.Context) (uint64, error) {
	roleIds := s.extractor.GetRoleIDs(ctx)
	if err := chk.CheckRole(ctx, fmt.Sprintf("%v", int32(pb.BulbasaurRole_ROLE_CANDIDATE)), roleIds); err != nil {
		return 0, err
	}

	bmId, err := s.extractor.GetUserID(ctx)
	if err != nil {
		return 0, err
	}
	return uint64(bmId), nil
}

/*
* HELPER FUNCTIONS
*/

// Store the intro question in a slice
func (s *Irelia) generateIntroQuestion(language string) string {
    var questions []string

    if language == "Vietnamese" {
        questions = []string{
            "Vui lòng cung cấp một cái nhìn tổng quan ngắn gọn về nền tảng chuyên môn và các kỹ năng chính của bạn.",
            "Nhìn lại hành trình nghề nghiệp của bạn, đâu là một lĩnh vực bạn đang tích cực phát triển và tại sao?",
            "Những điểm mạnh cốt lõi nào bạn nghĩ rằng bạn mang lại cho vai trò này và bạn đã thể hiện chúng như thế nào trong quá khứ?",
        }
    } else {
        questions = []string{
            "Please provide a brief overview of your professional background and key qualifications.",
            "Reflecting on your professional journey, what is one area you are actively working to develop and why?",
            "What core strengths do you believe you bring to a role like this, and how have you demonstrated them in the past?",
        }
    }

    // Seed the random number generator
    rand.Seed(time.Now().UnixNano())
    randomIndex := rand.Intn(len(questions))

    return questions[randomIndex]
}

// Store the position-specific questions in a slice
func (s *Irelia) generatePositionSpecificQuestions(position string, language string) string {
	var questions []string

    if language == "Vietnamese" {
        questions = []string{
            fmt.Sprintf("Bạn có thể mô tả một số dự án hấp dẫn nhất của bạn trong lĩnh vực %s không?", position),
            fmt.Sprintf("Những kinh nghiệm liên quan nào bạn có trong lĩnh vực %s?", position),
            fmt.Sprintf("Theo bạn, những thách thức chính hiện nay mà các chuyên gia trong lĩnh vực %s đang đối mặt là gì?", position),
            fmt.Sprintf("Bạn có thể chia sẻ hành trình của mình vào lĩnh vực %s không?", position),
            fmt.Sprintf("Những khía cạnh nào của công việc trong lĩnh vực %s mà bạn thấy đặc biệt thú vị?", position),
            fmt.Sprintf("Những xu hướng mới nổi nào trong lĩnh vực %s mà bạn cảm thấy hào hứng nhất và tại sao?", position),
            fmt.Sprintf("Những hiểu lầm phổ biến nào xung quanh nghề nghiệp trong lĩnh vực %s?", position),
            fmt.Sprintf("Bạn có thể giải thích về bất kỳ sáng kiến phát triển nghề nghiệp nào bạn đã thực hiện trong lĩnh vực %s không?", position),
            fmt.Sprintf("Bạn sẽ đưa ra lời khuyên gì cho một người mới bắt đầu sự nghiệp trong lĩnh vực %s?", position),
            fmt.Sprintf("Những khát vọng của bạn cho sự nghiệp trong lĩnh vực %s là gì?", position),
            fmt.Sprintf("Theo bạn, những kỹ năng quan trọng nhất để thành công trong lĩnh vực %s là gì?", position),
        }
    } else {
        questions = []string{
            fmt.Sprintf("Could you describe some of your most engaging projects within %s?", position),
            fmt.Sprintf("What relevant experiences do you possess in the field of %s?", position),
            fmt.Sprintf("In your opinion, what are the primary challenges currently facing professionals in %s?", position),
            fmt.Sprintf("Could you share your journey into the field of %s?", position),
            fmt.Sprintf("What aspects of working within %s do you find particularly fulfilling?", position),
            fmt.Sprintf("What emerging trends within %s are you most enthusiastic about and why?", position),
            fmt.Sprintf("What are some prevalent misconceptions surrounding the profession of %s?", position),
            fmt.Sprintf("Can you elaborate on any professional development initiatives you've undertaken within %s?", position),
            fmt.Sprintf("What key advice would you offer to an individual beginning their career in %s?", position),
            fmt.Sprintf("What are your aspirations for your career trajectory within %s?", position),
            fmt.Sprintf("In your perspective, what are the paramount skills required for success in %s?", position),
        }
    }
	rand.Seed(time.Now().UnixNano())
	randomIndex := rand.Intn(len(questions))

	return questions[randomIndex]
}

// Extract the substring after the last dot or dash in a string
func (s *Irelia) substringAfterLastDotOrDash(str string) string {
	lastDot := strings.LastIndex(str, ".")
	lastDash := strings.LastIndex(str, "-")

	if lastDot > lastDash {
		if lastDot == -1 {
			return ""
		}
		return str[lastDot+1:]
	} else if lastDash > lastDot {
		if lastDash == -1 {
			return ""
		}
		return str[lastDash+1:]
	} else {
		return "" // Neither '.' nor '-' found, or they are at the same experience (unlikely)
	}
}

// Add transitions to the question content
func (s *Irelia) addTransitionsToQuestion(question *ent.Question, voiceID string, language string) string {
	var responseTokens []string
    var transitionSentences []string

    if language == "Vietnamese" {
        responseTokens = []string{
            "Tôi hiểu.", "Nghe hay đấy.", "Thú vị.", "OK.", "Được rồi.", "Hiểu rồi.",
        }
        transitionSentences = []string{
            "Bây giờ, chúng ta hãy chuyển sang câu hỏi tiếp theo.", "Hãy tiếp tục với câu hỏi tiếp theo.", "Chuyển sang câu hỏi tiếp theo.",
            "Câu hỏi tiếp theo đây.", "Đây là câu hỏi tiếp theo.",
        }
    } else {
        responseTokens = []string{
            "I see.", "That sounds good.", "Interesting.", "Got it.", "Alright.", "Understood.",
        }
        transitionSentences = []string{
            "Now, let's move on to the next question.", "Let's proceed to the next question.", "Moving on to the next question.",
            "Next question coming up.", "Here's the next question.",
        }
    }

	rand.Seed(time.Now().UnixNano())
	if question.QuestionIndex == 1 {
		// Add an intro for the first question
		var intro string
        if language == "Vietnamese" {
            intro = fmt.Sprintf("Cảm ơn bạn đã tham gia buổi phỏng vấn hôm nay. Tôi là %s, rất vui được gặp bạn. Để bắt đầu, tôi sẽ hỏi bạn một số câu hỏi.", s.substringAfterLastDotOrDash(voiceID))
        } else {
            intro = fmt.Sprintf("Thanks for joining this interview session today. I'm %s, nice to meet you. To begin with, let me ask you some questions.", s.substringAfterLastDotOrDash(voiceID))
        }
		fullString := intro + " " + question.Content
		return fullString
	}
	responseToken := responseTokens[rand.Intn(len(responseTokens))]
	transition := transitionSentences[rand.Intn(len(transitionSentences))]
	fullString := responseToken + " " + transition + " " + question.Content
	return fullString
}

// Prepare the outro message based on the language
func (s *Irelia) prepareOutro(language string) string {
    if language == "Vietnamese" {
        return "Bạn đã hoàn thành buổi phỏng vấn. Bạn có thể kiểm tra kết quả sau vài phút. Hẹn gặp lại bạn trong một buổi phỏng vấn khác!"
    }
    return "You have successfully submitted the interview. You can check out the results in a few minutes. See you in another interview session!"
}

// Calculate the overall score based on the total score data
func getOverallScore(scoreData *pb.TotalScore) float64 {
    // Grade weights (A=4.0, B=3.0, C=2.0, D=1.0, F=0.0)
    weights := map[string]float64{
        "A": 4.0,
        "B": 3.0,
        "C": 2.0,
        "D": 1.0,
        "F": 0.0,
    }
    
    totalQuestions := scoreData.A + scoreData.B + scoreData.C + scoreData.D + scoreData.F
    if totalQuestions == 0 {
        return 0.0
    }
    
    weightedSum := float64(scoreData.A)*weights["A"] + 
                   float64(scoreData.B)*weights["B"] + 
                   float64(scoreData.C)*weights["C"] + 
                   float64(scoreData.D)*weights["D"] + 
                   float64(scoreData.F)*weights["F"]
    
    return weightedSum / float64(totalQuestions)
}

// Generate a unique cache key for lip-sync data
func md5sum(s string) string {
    h := md5.New()
    h.Write([]byte(s))
    return fmt.Sprintf("%x", h.Sum(nil))
}

// Generate a cache key for lip-sync data based on kind, voiceID, language, and content
func lipSyncCacheKey(kind, voiceID, language, content string, speed int32) string {
    // kind: "intro", "position", "outro"
    return fmt.Sprintf("lipsync:%s:%s:%s:%d:%x", kind, voiceID, language, speed, md5sum(content))
}