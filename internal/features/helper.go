package features

import (
	"bufio"
	"context"
	"crypto/md5"
	"fmt"
	"math/rand"
	"os"
	"path/filepath"
	"strings"
	"sync/atomic"
	"time"
	"github.com/spf13/viper"
	"go.uber.org/zap"
	"google.golang.org/protobuf/encoding/protojson"

	pb "irelia/api"
	chk "irelia/internal/utils/checker"
	"irelia/internal/utils/sse"
	"irelia/pkg/ent"
)

/*
* SERVICE FUNCTIONS
 */

func (s *Irelia) callDariusForGenerate(ctx context.Context, userID uint64, req *pb.NextQuestionRequest) (*pb.NextQuestionResponse, error) {
	// Log the request for debugging
	s.logger.Info("Sending request to Darius for question generation", zap.Any("request", req))

	// Call the Darius service
	return s.dariusClient.Generate(ctx, fmt.Sprintf("%d", userID), req)
}

func (s *Irelia) callDariusForScore(ctx context.Context, userID uint64, req *pb.ScoreInterviewRequest) (*pb.ScoreInterviewResponse, error) {
	// Log the request for debugging
	s.logger.Info("Sending request to Darius for scoring", zap.Any("request", req))

	// Call the Darius service
	return s.dariusClient.Score(ctx, fmt.Sprintf("%d", userID), req)
}

func (s *Irelia) callKarmaForLipSync(ctx context.Context, req *pb.LipSyncRequest) (*pb.LipSyncResponse, error) {
	// Log the request for debugging
	s.logger.Info("Sending request to Karma for lip-sync generation", zap.Any("request", req))

	// Call the Karma service
	return s.karmaClient.LipSync(ctx, req)
}

func (s *Irelia) callKarmaForScore(ctx context.Context, req *pb.ScoreFluencyRequest) (*pb.ScoreFluencyResponse, error) {
	// Log the request for debugging
	s.logger.Info("Sending request to Karma for fluency scoring", zap.Any("request", req))

	// Call the Karma service
	return s.karmaClient.Score(ctx, req)
}

// Generates the next question using Darius and saves it in the database
func (s *Irelia) prepareContent(ctx context.Context, userID uint64, interviewID string, submissions []*pb.QaPair, remainingQuestions int32, questionIndex int32) ([]*ent.Question, error) {
	// Retrieve the interview context
	interviewContext, err := s.repo.Interview.GetContext(ctx, interviewID)
	if err != nil {
		s.logger.Error("Failed to retrieve interview context", zap.String("interviewId", interviewID), zap.Error(err))
		return nil, fmt.Errorf("failed to retrieve interview context: %v", err)
	}

	// Provide default values for empty fields in the context
	if interviewContext.Position == "" {
		interviewContext.Position = "General"
	}
	if interviewContext.Experience == "" {
		interviewContext.Experience = "General"
	}
	if interviewContext.Language == "" {
		interviewContext.Language = "English"
	}
	if len(interviewContext.Skills) == 0 {
		interviewContext.Skills = []string{"English skills"}
	}

	// Prepare the Darius request
	dariusReq := &pb.NextQuestionRequest{
		InterviewId:        interviewID,
		Submissions:        submissions,
		RemainingQuestions: remainingQuestions,
		Context: &pb.Context{
			Position:       interviewContext.Position,
			Experience:     interviewContext.Experience,
			Language:       interviewContext.Language,
			Skills:         interviewContext.Skills,
			TotalQuestions: interviewContext.TotalQuestions,
			SkipCode:       interviewContext.SkipCode,
		},
	}

	var dariusResp *pb.NextQuestionResponse

	dariusResp, err = s.callDariusForGenerate(context.Background(), userID, dariusReq)
	if err != nil {
		s.logger.Error("Failed to generate questions", zap.String("interviewId", interviewID))
		return nil, fmt.Errorf("failed to generate questions: %v", err)
	}

	if len(dariusResp.Questions) == 0 {
		s.logger.Error("No questions generated by Darius", zap.String("interviewId", interviewID))
		return nil, fmt.Errorf("no next question generated")
	}

	// Save the generated question(s) in the database
	questions := []*ent.Question{}
	for i, content := range dariusResp.Questions {
		index := questionIndex + int32(i)
		if index > interviewContext.TotalQuestions {
			break
		}
		question := &ent.Question{
			QuestionIndex: index,
			InterviewID:   interviewID,
			Content:       content,
		}
		questions = append(questions, question)
	}

	return questions, nil
}

// Prepare lip-sync data for a question synchronously
func (s *Irelia) prepareLipSync(ctx context.Context, question *ent.Question, interview *ent.Interview, isOutro bool, isTimeout bool) (*ent.Question, error) {
	if question == nil {
		s.logger.Error("Question is nil, cannot prepare lip sync", zap.String("interviewId", interview.ID))
		return nil, fmt.Errorf("question is nil, cannot prepare lip sync")
	}

	s.logger.Info("Preparing lip sync", zap.String("interviewId", interview.ID), zap.String("content", question.Content))

	// Prepare the full string for lip-sync
	var fullString string
	var cacheKind string
	if isOutro {
		fullString = question.Content
		cacheKind = "outro"
	} else if question.QuestionIndex == 1 {
		fullString = s.addTransitionsToQuestion(question, interview.VoiceID, interview.Language, isTimeout)
		cacheKind = "intro"
	} else {
		fullString = s.addTransitionsToQuestion(question, interview.VoiceID, interview.Language, isTimeout)
		cacheKind = ""
	}

	// Only cache for intro, position, outro
	var cacheKey string
	if cacheKind != "" && s.redis != nil {
		cacheKey = lipSyncCacheKey(cacheKind, interview.VoiceID, interview.Language, fullString, interview.Speed)
		// Try to get from cache
		val, err := s.redis.Get(ctx, cacheKey)
		if err == nil && val != nil {
			var cachedResp pb.LipSyncResponse
			if err := protojson.Unmarshal([]byte(val), &cachedResp); err == nil {
				question.Audio = cachedResp.Audio
				question.Lipsync = cachedResp.Lipsync
				return question, nil
			}
		}
	}

	// Call the Karma service to generate lip-sync data
	karmaReq := &pb.LipSyncRequest{
		InterviewId: interview.ID,
		Content:     fullString,
		VoiceId:     interview.VoiceID,
		Speed:       interview.Speed,
	}

	karmaResp, err := s.callKarmaForLipSync(ctx, karmaReq)
	if err != nil {
		return nil, fmt.Errorf("failed to generate lip sync: %v", err)
	}

	// Update the question with the generated lip-sync data
	question.Audio = karmaResp.Audio
	question.Lipsync = karmaResp.Lipsync

	// Save to cache if intro/position/outro
	if cacheKind != "" && s.redis != nil {
		s.redis.Set(ctx, cacheKey, karmaResp, 1*time.Hour)
		s.logger.Info("Cached lip sync data", zap.String("cacheKey", cacheKey))
	}

	return question, nil
}

func (s *Irelia) prepareQuestionSafe(job QuestionPreparationJob) {
	jobKey := fmt.Sprintf("%s:%d", job.InterviewID, job.NextQuestionID)

	// Check if already in progress with better logging
	s.preparationMutex.Lock()
	if s.preparationStatus[job.InterviewID] == nil {
		s.preparationStatus[job.InterviewID] = make(map[int32]bool)
	}
	if s.preparationStatus[job.InterviewID][job.NextQuestionID] {
		s.preparationMutex.Unlock()
		s.logger.Info("Question preparation already in progress, skipping", zap.String("jobKey", jobKey),
			zap.String("interviewID", job.InterviewID),
			zap.Int32("questionID", job.NextQuestionID))
		return
	}
	s.preparationStatus[job.InterviewID][job.NextQuestionID] = true
	s.preparationMutex.Unlock()

	s.logger.Info("Starting question preparation", zap.String("jobKey", jobKey),
		zap.String("interviewID", job.InterviewID),
		zap.Int32("questionID", job.NextQuestionID),
		zap.Uint64("userID", job.UserID))

	// Cleanup status when done
	defer func() {
		s.preparationMutex.Lock()
		delete(s.preparationStatus[job.InterviewID], job.NextQuestionID)
		if len(s.preparationStatus[job.InterviewID]) == 0 {
			delete(s.preparationStatus, job.InterviewID)
		}
		s.preparationMutex.Unlock()

		s.logger.Info("Finished question preparation cleanup", zap.String("jobKey", jobKey))
	}()

	// Add timeout context for the preparation
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	if err := s.prepareQuestion(ctx, job); err != nil {
		s.logger.Error("Question preparation failed", zap.String("jobKey", jobKey),
			zap.Error(err))
	} else {
		s.logger.Info("Question preparation completed successfully", zap.String("jobKey", jobKey))
	}
}

func (s *Irelia) prepareQuestion(ctx context.Context, job QuestionPreparationJob) error {
	// Check if question already exists
	exists, err := s.repo.Question.Exists(ctx, job.InterviewID, job.NextQuestionID)
	if err != nil && !ent.IsNotFound(err) {
		s.logger.Error("Failed to check if question exists", zap.String("interviewID", job.InterviewID),
			zap.Int32("questionID", job.NextQuestionID),
			zap.Error(err))
		return fmt.Errorf("failed to check question existence: %w", err)
	}
	if exists {
		s.logger.Info("Question already exists, skipping generation", zap.String("interviewID", job.InterviewID),
			zap.Int32("questionID", job.NextQuestionID))
		return nil
	}

	questions := job.Questions
	isTimeout := false
	if len(questions) == 0 {
		s.logger.Debug("No pre-prepared questions, generating from context", zap.String("interviewID", job.InterviewID),
			zap.Int32("questionID", job.NextQuestionID))

		submissions, err := s.repo.Question.GetQaPair(ctx, job.InterviewID, viper.GetInt("context_qa_length"))
		if err != nil && !ent.IsNotFound(err) {
			s.logger.Error("Failed to retrieve submissions for Darius", zap.String("interviewID", job.InterviewID),
				zap.Error(err))
			return fmt.Errorf("failed to retrieve submissions: %w", err)
		}
		// // Check if the last question already answered
		// if job.NextQuestionID > 1 && submissions[len(submissions)-1].Answer == "" {
		// 	isTimeout = true
		// }

		s.logger.Debug("Retrieved submissions for question generation", zap.String("interviewID", job.InterviewID),
			zap.Int("submissionCount", len(submissions)))

		questions, err = s.prepareContent(ctx, job.UserID, job.InterviewID, submissions,
			job.Interview.TotalQuestions-job.NextQuestionID+1, job.NextQuestionID)
		if err != nil {
			s.logger.Error("Failed to generate questions from content", zap.String("interviewID", job.InterviewID),
				zap.Error(err))
			return fmt.Errorf("failed to generate questions: %w", err)
		}

		s.logger.Debug("Generated questions from content", zap.String("interviewID", job.InterviewID),
			zap.Int("questionCount", len(questions)))
	} else {
		s.logger.Debug("Using pre-prepared questions", zap.String("interviewID", job.InterviewID),
			zap.Int("questionCount", len(questions)))
	}

	// Prepare lip sync for each question
	var publicQuestions []*ent.PublicQuestion
	for i, question := range questions {
		if job.NextQuestionID+int32(i) > job.Interview.TotalQuestions {
			break
		}

		publicQuestions = append(publicQuestions, &ent.PublicQuestion{
			Position:   job.Interview.Position,
			Experience: job.Interview.Experience,
			Language:   job.Interview.Language,
			Content:    question.Content,
		})

		s.logger.Debug("Preparing lip sync for question", zap.String("interviewID", job.InterviewID),
			zap.Int32("questionID", job.NextQuestionID+int32(i)))

		var err error
		questions[i], err = s.prepareLipSync(ctx, question, job.Interview, false, isTimeout)
		if err != nil {
			s.logger.Error("Failed to prepare lip sync for question", zap.String("interviewID", job.InterviewID),
				zap.Int32("questionID", job.NextQuestionID+int32(i)),
				zap.Error(err))
			continue
		}
		if err := s.repo.Question.Create(ctx, job.UserID, question); err != nil {
			if ent.IsConstraintError(err) {
				s.logger.Warn("Duplicate question detected, skipping creation",
					zap.String("interviewID", job.InterviewID),
					zap.Int32("questionID", job.NextQuestionID+int32(i)))
				continue
			}
			s.logger.Error("Failed to save questions", zap.String("interviewID", job.InterviewID),
				zap.Int32("questionID", job.NextQuestionID+int32(i)),
				zap.Error(err))
			continue
		}
	}
	// Save public questions if any
	if len(publicQuestions) > 0 {
		if err := s.repo.PublicQuestion.CreateBulk(ctx, publicQuestions); err != nil {
			s.logger.Error("Failed to save public questions", zap.String("interviewID", job.InterviewID),
				zap.Error(err))
			return fmt.Errorf("failed to save public questions: %w", err)
		}
		s.logger.Debug("Successfully saved public questions", zap.String("interviewID", job.InterviewID), zap.Int("publicQuestionCount", len(publicQuestions)))
	}

	s.logger.Info("Successfully prepared and saved questions", zap.String("interviewID", job.InterviewID),
		zap.Int32("startingQuestionID", job.NextQuestionID),
		zap.Int("questionCount", len(questions)))

	return nil
}

func (s *Irelia) ensureQuestionWorkerPool() {
	if atomic.LoadInt64(&s.questionWorkerPool.activeWorkers) == 0 {
		s.logger.Warn("All question workers have exited, restarting worker pool")
		s.questionWorkerPool.Start(s)
	}
}

func (s *Irelia) getUserID(ctx context.Context) (uint64, error) {
	roleIds := s.extractor.GetRoleIDs(ctx)
	if err := chk.CheckRole(ctx, fmt.Sprintf("%v", int32(pb.BulbasaurRole_ROLE_CANDIDATE)), roleIds); err != nil {
		return 0, err
	}

	bmId, err := s.extractor.GetUserID(ctx)
	if err != nil {
		return 0, err
	}
	return uint64(bmId), nil
}

/*
* HELPER FUNCTIONS
 */

// handleQuestionTimeout handles timeout for a question
func (s *Irelia) handleQuestionTimeout(interviewID string, questionIndex int32, userID uint64) {
	s.logger.Info("Handling question timeout",
		zap.String("interviewID", interviewID),
		zap.Int32("questionIndex", questionIndex),
		zap.Uint64("userID", userID))

	// Send notification to frontend through your preferred method
	// This could be WebSocket, gRPC stream, or message queue
	s.sendTimeoutNotification(userID, interviewID, questionIndex)

	// Optionally, you can automatically submit an empty answer
	// or mark the question as timed out
	go s.handleTimeoutSubmission(interviewID, questionIndex, userID)
}

// sendTimeoutNotification sends a notification to the frontend
func (s *Irelia) sendTimeoutNotification(userID uint64, interviewID string, questionIndex int32) {
	notification := map[string]interface{}{
		"type":          "question_timeout",
		"interviewID":   interviewID,
		"questionIndex": questionIndex,
		"timestamp":     time.Now().Unix(),
	}

	s.logger.Info("Sending timeout notification",
		zap.Uint64("userID", userID),
		zap.Any("notification", notification))

	if sse.SendToUser(userID, notification) {
		s.logger.Info("Timeout notification sent via SSE",
			zap.Uint64("userID", userID))
		return
	}

	// Fallback options if SSE is not available
	s.logger.Warn("SSE not available for user, using fallback methods",
		zap.Uint64("userID", userID))
}

// handleTimeoutSubmission automatically handles timeout submission
func (s *Irelia) handleTimeoutSubmission(interviewID string, questionIndex int32, userID uint64) {
	ctx := context.Background()

	question, err := s.repo.Question.Get(ctx, interviewID, questionIndex)
	if err != nil {
		s.logger.Error("Failed to retrieve question for timeout handling",
			zap.String("interviewID", interviewID),
			zap.Int32("questionIndex", questionIndex),
			zap.Error(err))
		return
	}

	// Only handle if question is still unanswered
	if question.Status == pb.QuestionStatus_QUESTION_STATUS_NEW {
		question.Answer = "" // Empty answer for timeout
		question.Status = pb.QuestionStatus_QUESTION_STATUS_SKIPPED

		if err := s.repo.Question.Update(ctx, userID, question); err != nil {
			s.logger.Error("Failed to update question on timeout",
				zap.String("interviewID", interviewID),
				zap.Int32("questionIndex", questionIndex),
				zap.Error(err))
		}
	}
}

/*
* HELPER FUNCTIONS
 */

// Store the intro question in a slice
func (s *Irelia) generateIntroQuestion(language string) string {
	var questions []string

	if language == "Vietnamese" {
		questions = []string{
			"Bạn có thể giới thiệu về bản thân mình không?",
			"Bạn có thể cho tôi biết một chút về bản thân mình được không?",
			"Bạn có thể giới thiệu ngắn gọn về bản thân mình không?",
			"Bạn có thể chia sẻ một chút về bạn không?",
			"Bạn có thể giới thiệu về bản thân mình được không?",
		}
	} else {
		questions = []string{
			"Can you introduce yourself?",
			"Could you tell me a bit about yourself?",
			"Please introduce yourself briefly.",
			"Can you share a little about who you are?",
			"Would you mind introducing yourself?",
		}
	}

	// Seed the random number generator
	rand.Seed(time.Now().UnixNano())
	randomIndex := rand.Intn(len(questions))

	return questions[randomIndex]
}

// Store the position-specific questions in a slice
func (s *Irelia) generatePositionSpecificQuestions(position string, language string) string {
	var questions []string

	if language == "Vietnamese" {
		questions = []string{
			fmt.Sprintf("Bạn có thể mô tả một số dự án hấp dẫn nhất của bạn trong lĩnh vực %s không?", position),
			fmt.Sprintf("Những kinh nghiệm liên quan nào bạn có trong lĩnh vực %s?", position),
			fmt.Sprintf("Theo bạn, những thách thức chính hiện nay mà các chuyên gia trong lĩnh vực %s đang đối mặt là gì?", position),
			fmt.Sprintf("Bạn có thể chia sẻ hành trình của mình vào lĩnh vực %s không?", position),
			fmt.Sprintf("Những khía cạnh nào của công việc trong lĩnh vực %s mà bạn thấy đặc biệt thú vị?", position),
			fmt.Sprintf("Những xu hướng mới nổi nào trong lĩnh vực %s mà bạn cảm thấy hào hứng nhất và tại sao?", position),
			fmt.Sprintf("Những hiểu lầm phổ biến nào xung quanh nghề nghiệp trong lĩnh vực %s?", position),
			fmt.Sprintf("Bạn có thể giải thích về bất kỳ sáng kiến phát triển nghề nghiệp nào bạn đã thực hiện trong lĩnh vực %s không?", position),
			fmt.Sprintf("Bạn sẽ đưa ra lời khuyên gì cho một người mới bắt đầu sự nghiệp trong lĩnh vực %s?", position),
			fmt.Sprintf("Những khát vọng của bạn cho sự nghiệp trong lĩnh vực %s là gì?", position),
			fmt.Sprintf("Theo bạn, những kỹ năng quan trọng nhất để thành công trong lĩnh vực %s là gì?", position),
			fmt.Sprintf("Bạn thường làm thế nào để cập nhật kiến thức mới trong lĩnh vực %s?", position),
			fmt.Sprintf("Bạn có thể kể về một tình huống khó khăn trong lĩnh vực %s và cách bạn vượt qua nó?", position),
			fmt.Sprintf("Bạn đã từng làm việc nhóm trong lĩnh vực %s chưa? Vai trò của bạn là gì?", position),
			fmt.Sprintf("Bạn đánh giá thế nào về tác động xã hội của công việc trong lĩnh vực %s?", position),
			fmt.Sprintf("Điều gì khiến bạn tự hào nhất trong quá trình làm việc ở lĩnh vực %s?", position),
			fmt.Sprintf("Bạn xử lý thế nào khi gặp sự bất đồng quan điểm trong nhóm làm việc thuộc lĩnh vực %s?", position),
			fmt.Sprintf("Bạn có thể kể về một quyết định khó khăn bạn từng đưa ra trong lĩnh vực %s không?", position),
			"Nếu người quản lý của bạn yêu cầu bạn làm điều gì đó mà bạn không đồng ý, bạn sẽ làm gì?",
			"Điểm bạn cần cải thiện trong thời điểm này là gì? Bạn có kế hoạch để cải thiện những điểm này chưa?",
			"Điều gì ở đồng nghiệp cũ/ người quản lý cũ làm bạn khó chịu?",
		}
	} else {
		questions = []string{
			fmt.Sprintf("Could you describe some of your most engaging projects within %s?", position),
			fmt.Sprintf("What relevant experiences do you possess in the field of %s?", position),
			fmt.Sprintf("In your opinion, what are the primary challenges currently facing professionals in %s?", position),
			fmt.Sprintf("Could you share your journey into the field of %s?", position),
			fmt.Sprintf("What aspects of working within %s do you find particularly fulfilling?", position),
			fmt.Sprintf("What emerging trends within %s are you most enthusiastic about and why?", position),
			fmt.Sprintf("What are some prevalent misconceptions surrounding the profession of %s?", position),
			fmt.Sprintf("Can you elaborate on any professional development initiatives you've undertaken within %s?", position),
			fmt.Sprintf("What key advice would you offer to an individual beginning their career in %s?", position),
			fmt.Sprintf("What are your aspirations for your career trajectory within %s?", position),
			fmt.Sprintf("In your perspective, what are the paramount skills required for success in %s?", position),
			fmt.Sprintf("How do you stay updated with the latest advancements in %s?", position),
			fmt.Sprintf("Can you talk about a challenging situation in %s and how you handled it?", position),
			fmt.Sprintf("Have you collaborated in a team within the %s field? What role did you play?", position),
			fmt.Sprintf("How do you perceive the societal impact of work done in the %s field?", position),
			fmt.Sprintf("What is your proudest achievement so far in %s?", position),
			fmt.Sprintf("How do you manage conflicts or disagreements within a team in %s?", position),
			fmt.Sprintf("Could you describe a difficult decision you've had to make in the field of %s?", position),
			"If your manager asked you to do something that you disagree with, what would you do?",
			"What are things you need to improve at this point? Do you have a plan for the improvements?",
			"What is it about your former coworker / former manager that annoys you?",
		}
	}
	rand.Seed(time.Now().UnixNano())
	randomIndex := rand.Intn(len(questions))

	return questions[randomIndex]
}

// Extract the substring after the last dot or dash in a string
func (s *Irelia) substringAfterLastDotOrDash(str string) string {
	lastDot := strings.LastIndex(str, ".")
	lastDash := strings.LastIndex(str, "-")

	if lastDot > lastDash {
		if lastDot == -1 {
			return ""
		}
		return str[lastDot+1:]
	} else if lastDash > lastDot {
		if lastDash == -1 {
			return ""
		}
		return str[lastDash+1:]
	} else {
		return "" // Neither '.' nor '-' found, or they are at the same experience (unlikely)
	}
}

// Add transitions to the question content
func (s *Irelia) addTransitionsToQuestion(question *ent.Question, voiceID string, language string, isTimeout bool) string {
	var responseTokens []string
	var transitionSentences []string

	if language == "Vietnamese" {
		responseTokens = []string{
			"Tôi hiểu.", "Nghe hay đấy.", "Thú vị.", "OK.", "Được rồi.", "Hiểu rồi.",
		}
		transitionSentences = []string{
			"Bây giờ, chúng ta hãy chuyển sang câu hỏi tiếp theo.", "Hãy tiếp tục với câu hỏi tiếp theo.", "Chuyển sang câu hỏi tiếp theo.",
			"Câu hỏi tiếp theo đây.", "Đây là câu hỏi tiếp theo.",
		}
	} else {
		responseTokens = []string{
			"I see.", "That sounds good.", "Interesting.", "Got it.", "Alright.", "Understood.",
		}
		transitionSentences = []string{
			"Now, let's move on to the next question.", "Let's proceed to the next question.", "Moving on to the next question.",
			"Next question coming up.", "Here's the next question.",
		}
	}

	if isTimeout {
		if language == "Vietnamese" {
			responseTokens = []string{
				"Bạn đã hết thời gian trả lời.",
			}
		} else {
			responseTokens = []string{
				"You have run out of time to answer.",
			}
		}
	}

	rand.Seed(time.Now().UnixNano())
	if question.QuestionIndex == 1 {
		// Add an intro for the first question
		var intro string
		if language == "Vietnamese" {
			intro = fmt.Sprintf("Cảm ơn bạn đã tham gia buổi phỏng vấn hôm nay. Tôi là %s, rất vui được gặp bạn. Để bắt đầu, tôi sẽ hỏi bạn một số câu hỏi.", s.substringAfterLastDotOrDash(voiceID))
		} else {
			intro = fmt.Sprintf("Thanks for joining this interview session today. I'm %s, nice to meet you. To begin with, let me ask you some questions.", s.substringAfterLastDotOrDash(voiceID))
		}
		fullString := intro + " " + question.Content
		return fullString
	}
	responseToken := responseTokens[rand.Intn(len(responseTokens))]
	transition := transitionSentences[rand.Intn(len(transitionSentences))]
	fullString := responseToken + " " + transition + " " + question.Content
	return fullString
}

// Prepare the outro message based on the language
func (s *Irelia) prepareOutro(language string) string {
	if language == "Vietnamese" {
		return "Bạn đã hoàn thành buổi phỏng vấn. Bạn có thể kiểm tra kết quả sau vài phút. Hẹn gặp lại bạn trong một buổi phỏng vấn khác!"
	}
	return "You have successfully submitted the interview. You can check out the results in a few minutes. See you in another interview session!"
}

func (s *Irelia) loadDemoQuestions(topic string) ([]*pb.DemoQuestion, error) {
	filename := fmt.Sprintf("%s.jsonl", strings.ReplaceAll(topic, "-", "_"))
	demoDir := viper.GetString("demo_data_dir")
    var path string

    if demoDir != "" {
        path = filepath.Join(demoDir, filename)
    } else {
        exePath, err := os.Executable()
        if err != nil {
            return nil, fmt.Errorf("failed to get executable path: %w", err)
        }
        exeDir := filepath.Dir(exePath)
        path = filepath.Join(exeDir, "..", "demo", filename)
    }

    s.logger.Info("Trying to open demo file", zap.String("path", path))
	f, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open demo file: %w", err)
	}
	defer f.Close()

	var questions []*pb.DemoQuestion
    reader := bufio.NewReader(f)
    for {
        line, err := reader.ReadBytes('\n')
        if len(line) > 0 {
            var q pb.DemoQuestion
            lineStr := strings.TrimSpace(string(line))
            if lineStr == "" {
                continue
            }
            if err := protojson.Unmarshal([]byte(lineStr), &q); err != nil {
                return nil, fmt.Errorf("failed to parse demo question: %w", err)
            }
            questions = append(questions, &q)
        }
        if err != nil {
            if err.Error() == "EOF" {
                break
            }
            return nil, err
        }
    }
    return questions, nil
}

// Calculate the overall score based on the total score data
func getOverallScore(scoreData *pb.TotalScore) float64 {
	// Grade weights (A=4.0, B=3.0, C=2.0, D=1.0, F=0.0)
	weights := map[string]float64{
		"A": 4.0,
		"B": 3.0,
		"C": 2.0,
		"D": 1.0,
		"F": 0.0,
	}

	totalQuestions := scoreData.A + scoreData.B + scoreData.C + scoreData.D + scoreData.F
	if totalQuestions == 0 {
		return 0.0
	}

	weightedSum := float64(scoreData.A)*weights["A"] +
		float64(scoreData.B)*weights["B"] +
		float64(scoreData.C)*weights["C"] +
		float64(scoreData.D)*weights["D"] +
		float64(scoreData.F)*weights["F"]

	return weightedSum / float64(totalQuestions)
}

// Generate a unique cache key for lip-sync data
func md5sum(s string) string {
	h := md5.New()
	h.Write([]byte(s))
	return fmt.Sprintf("%x", h.Sum(nil))
}

// Generate a cache key for lip-sync data based on kind, voiceID, language, and content
func lipSyncCacheKey(kind, voiceID, language, content string, speed int32) string {
	// kind: "intro", "position", "outro"
	return fmt.Sprintf("lipsync:%s:%s:%s:%d:%x", kind, voiceID, language, speed, md5sum(content))
}
