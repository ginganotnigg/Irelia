package features

import (
	"context"
	"fmt"
	pb "irelia/api"
	chk "irelia/internal/utils/checker"
	"irelia/internal/utils/tx"
	"irelia/pkg/ent"
	"math/rand"
	"strings"
	"time"

	"github.com/spf13/viper"
	"go.uber.org/zap"
)

/*
* SERVICE FUNCTIONS
 */

func (s *Irelia) callDariusForGenerate(ctx context.Context, req *pb.NextQuestionRequest) (*pb.NextQuestionResponse, error) {
	// Construct the payload to match the expected structure
	submissions := make([]map[string]interface{}, len(req.Submissions))
	for i, submission := range req.Submissions {
		submissions[i] = map[string]interface{}{
			"question": submission.Question,
			"answer":   submission.Answer,
		}
	}

	payload := map[string]interface{}{
		// "context": map[string]interface{}{
		// 	"position":     req.Context.Position,
		// 	"experience":   req.Context.Experience,
		// 	"language":     req.Context.Language,
		// 	"skills":       req.Context.Skills,
		// 	"maxQuestions": req.Context.TotalQuestions,
		// 	"skipCode":     req.Context.SkipCode,
		// },
		"context": map[string]interface{}{
			"field":        req.Context.Position,
			"position":     req.Context.Experience,
			"language":     req.Context.Language,
			"level":        "Easy",
			"maxQuestions": req.Context.TotalQuestions,
			"coding":       false,
		},
		"submissions":        submissions,
		"remainingQuestions": req.RemainingQuestions,
	}

	return s.dariusClient.Generate(ctx, payload)
}

func (s *Irelia) callDariusForScore(ctx context.Context, req *pb.ScoreInterviewRequest) (*pb.ScoreInterviewResponse, error) {
	// Construct the payload to match the expected structure
	submissions := make([]map[string]any, len(req.Submissions))
	for i, submission := range req.Submissions {
		submissions[i] = map[string]any{
			"index":       int32(i + 1),
			"question":    submission.Question,
			"answer":      submission.Answer,
		}
	}

	payload := map[string]any{
		"submissions": submissions,
	}
	s.logger.Info("Sending request to Darius for scoring", zap.Any("payload", payload))
	return s.dariusClient.Score(ctx, payload)
}

func (s *Irelia) callKarma(ctx context.Context, req *pb.LipSyncRequest) (*pb.LipSyncResponse, error) {
	payload := map[string]interface{}{
		"content": req.Content,
		"voiceId": req.VoiceId,
		"speed":   req.Speed,
	}
	return s.karmaClient.LipSync(ctx, payload)
}

// Generates the next question using Darius and saves it in the database
func (s *Irelia) generateNextQuestion(ctx context.Context, interviewID string, userID uint64, submissions []*pb.QaPair, remainingQuestions int32, questionIndex int32) (*ent.Question, error) {
	// Retrieve the interview context
	interviewContext, err := s.repo.Interview.GetContext(ctx, interviewID)
	if err != nil {
		s.logger.Error("Failed to retrieve interview context", zap.String("interviewId", interviewID), zap.Error(err))
		return nil, fmt.Errorf("failed to retrieve interview context: %v", err)
	}

	// Provide default values for empty fields in the context
	if interviewContext.Position == "" {
		interviewContext.Position = "General"
	}
	if interviewContext.Experience == "" {
		interviewContext.Experience = "General"
	}
	if interviewContext.Language == "" {
		interviewContext.Language = "English"
	}
	if len(interviewContext.Skills) == 0 {
		interviewContext.Skills = []string{"English skills"}
	}

	// Prepare the Darius request
	dariusReq := &pb.NextQuestionRequest{
		InterviewId:        interviewID,
		Submissions:        submissions,
		RemainingQuestions: remainingQuestions,
		Context: &pb.Context{
			Position:       interviewContext.Position,
			Experience:     interviewContext.Experience,
			Language:       interviewContext.Language,
			Skills:         interviewContext.Skills,
			TotalQuestions: interviewContext.TotalQuestions,
			SkipCode:       interviewContext.SkipCode,
		},
	}

	var dariusResp *pb.NextQuestionResponse

	dariusResp, err = s.callDariusForGenerate(context.Background(), dariusReq)
	if err != nil {
		s.logger.Error("Failed to generate questions", zap.String("interviewId", interviewID))
		return nil, fmt.Errorf("failed to generate questions: %v", err)
	}

	if len(dariusResp.Questions) == 0 {
		s.logger.Error("No questions generated by Darius", zap.String("interviewId", interviewID))
		return nil, fmt.Errorf("no next question generated")
	}

	// Save the generated question(s) in the database
	for i, content := range dariusResp.Questions {
		index := questionIndex + int32(i)
		if index > interviewContext.TotalQuestions {
			break
		}
		question := &ent.Question{
			QuestionIndex: index,
			InterviewID:   interviewID,
			Content:       content,
		}
		if txErr := tx.WithTransaction(ctx, s.repo.Ent, func(ctx context.Context, tx tx.Tx) error {
			fnErr := s.repo.Question.Create(ctx, tx, userID, question)
			return fnErr
		}); txErr != nil {
			s.logger.Error("Failed to save generated question", zap.String("interviewId", interviewID), zap.Int32("questionIndex", question.QuestionIndex), zap.Error(txErr))
			return nil, txErr
		}
	}

	// Return the first generated question
	firstQuestion, _ := s.repo.Question.Get(ctx, interviewID, questionIndex)

	return firstQuestion, nil
}

// Prepare lip-sync data for a question synchronously
func (s *Irelia) prepareLipSync(ctx context.Context, interviewID string, userID uint64, question *ent.Question, voiceID string, speed int32, isOutro bool) error {
	if question == nil {
		s.logger.Error("Question is nil, cannot prepare lip sync", zap.String("interviewId", interviewID))
		return fmt.Errorf("question is nil, cannot prepare lip sync")
	}

	s.logger.Info("Preparing lip sync", zap.String("interviewId", interviewID), zap.String("content", question.Content))

	// Prepare the full string for lip-sync
	var fullString string
	if isOutro {
		fullString = question.Content
	} else {
		fullString = s.addTransitionsToQuestion(question, voiceID)
	}

	// Call the Karma service to generate lip-sync data
	karmaReq := &pb.LipSyncRequest{
		InterviewId: interviewID,
		Content:     fullString,
		VoiceId:     voiceID,
		Speed:       speed,
	}

	karmaResp, err := s.callKarma(ctx, karmaReq)
	if err != nil {
		return fmt.Errorf("failed to generate lip sync: %v", err)
	}

	// Update the question with the generated lip-sync data
	question.Audio = karmaResp.Audio
	question.Lipsync = karmaResp.Lipsync

	if isOutro {
		return nil
	}

	// Save the updated question in the database within a transaction
	if txErr := tx.WithTransaction(ctx, s.repo.Ent, func(ctx context.Context, tx tx.Tx) error {
		return s.repo.Question.Update(ctx, tx, userID, question)
	}); txErr != nil {
		s.logger.Error("Failed to save question's lip-sync data", zap.Error(txErr))
		return txErr
	}

	return nil
}

// Prepare question data asynchronously
func (s *Irelia) asyncPrepareQuestion(interviewID string, userID uint64, nextQuestionID int32, interview *ent.Interview) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	exists, err := s.repo.Question.Exists(ctx, interviewID, nextQuestionID)
	if err != nil {
		s.logger.Error("Failed to check if question exists", zap.Error(err))
		return
	}

	if exists {
		s.logger.Info("Question already exists, skipping generation", zap.Int32("questionID", nextQuestionID))
	} else {
		submissions, err := s.repo.Question.GetQaPair(ctx, interviewID, viper.GetInt("context_qa_length"))
		if err != nil {
			s.logger.Error("Failed to retrieve submissions for Darius", zap.Error(err))
			return
		}

		s.logger.Info("Submissions for Darius", zap.Any("submissions", submissions))

		_, err = s.generateNextQuestion(ctx, interviewID, userID, submissions, interview.TotalQuestions-nextQuestionID+1, nextQuestionID)
		if err != nil {
			s.logger.Error("Failed to generate next question", zap.Error(err))
			return
		}
	}

	nextQuestion, err := s.repo.Question.Get(ctx, interviewID, nextQuestionID)
	if err != nil {
		s.logger.Error("Failed to retrieve next question", zap.Error(err))
		return
	}

	if nextQuestion != nil {
		// Prepare lip-sync data for the next question
		if err := s.prepareLipSync(ctx, interviewID, userID, nextQuestion, interview.VoiceID, interview.Speed, false); err != nil {
			s.logger.Error("Failed to prepare lip sync for the next question", zap.Error(err))
		}
	}
}

func (s *Irelia) prepareQuestion(interviewID string, userID uint64, questionIndex int32, interview *ent.Interview) {
	questionsToPrepare := viper.GetInt("questions_to_prepare")
	for i := 1; i <= questionsToPrepare; i++ {
		nextQuestionID := int32(questionIndex + 1)
		if nextQuestionID > interview.TotalQuestions {
			break
		}

		go s.asyncPrepareQuestion(interviewID, userID, nextQuestionID, interview)
		s.logger.Info("Preparing question", zap.String("interviewID", interviewID), zap.Int32("questionID", nextQuestionID))
	}
}

func (s *Irelia) getUserID(ctx context.Context) (uint64, error) {
	roleIds := s.extractor.GetRoleIDs(ctx)
	if err := chk.CheckRole(ctx, fmt.Sprintf("%v", int32(pb.BulbasaurRole_ROLE_CANDIDATE)), roleIds); err != nil {
		return 0, err
	}

	bmId, err := s.extractor.GetUserID(ctx)
	if err != nil {
		return 0, err
	}
	return uint64(bmId), nil
}

/*
* HELPER FUNCTIONS
 */

// Store the intro question in a slice
func (s *Irelia) generateIntroQuestion() string {
	questions := []string{
		"Please provide a brief overview of your professional background and key qualifications.",
		"Reflecting on your professional journey, what is one area you are actively working to develop and why?",
		"What core strengths do you believe you bring to a role like this, and how have you demonstrated them in the past?",
	}

	// Seed the random number generator
	rand.Seed(time.Now().UnixNano())
	randomIndex := rand.Intn(len(questions))

	return questions[randomIndex]
}

// Store the position-specific questions in a slice
func (s *Irelia) generatePositionSpecificQuestions(position string) string {
	questions := []string{
		fmt.Sprintf("Could you describe some of your most engaging projects within %s?", position),
		fmt.Sprintf("What relevant experiences do you possess in the field of %s?", position),
		fmt.Sprintf("In your opinion, what are the primary challenges currently facing professionals in %s?", position),
		fmt.Sprintf("Could you share your journey into the field of %s?", position),
		fmt.Sprintf("What aspects of working within %s do you find particularly fulfilling?", position),
		fmt.Sprintf("What emerging trends within %s are you most enthusiastic about and why?", position),
		fmt.Sprintf("What are some prevalent misconceptions surrounding the profession of %s?", position),
		fmt.Sprintf("Can you elaborate on any professional development initiatives you've undertaken within %s?", position),
		fmt.Sprintf("What key advice would you offer to an individual beginning their career in %s?", position),
		fmt.Sprintf("What are your aspirations for your career trajectory within %s?", position),
		fmt.Sprintf("In your perspective, what are the paramount skills required for success in %s?", position),
	}
	rand.Seed(time.Now().UnixNano())
	randomIndex := rand.Intn(len(questions))

	return questions[randomIndex]
}

// Extract the substring after the last dot or dash in a string
func (s *Irelia) substringAfterLastDotOrDash(str string) string {
	lastDot := strings.LastIndex(str, ".")
	lastDash := strings.LastIndex(str, "-")

	if lastDot > lastDash {
		if lastDot == -1 {
			return ""
		}
		return str[lastDot+1:]
	} else if lastDash > lastDot {
		if lastDash == -1 {
			return ""
		}
		return str[lastDash+1:]
	} else {
		return "" // Neither '.' nor '-' found, or they are at the same experience (unlikely)
	}
}

// Add transitions to the question content
func (s *Irelia) addTransitionsToQuestion(question *ent.Question, voiceID string) string {
	responseTokens := []string{
		"I see.", "That sounds good.", "Interesting.", "Got it.", "Alright.", "Understood.",
	}
	transitionSentences := []string{
		"Now, let's move on to the next question.", "Let's proceed to the next question.", "Moving on to the next question.",
		"Next question coming up.", "Here's the next question.",
	}

	rand.Seed(time.Now().UnixNano())
	if question.QuestionIndex == 1 {
		// Add an intro for the first question
		intro := fmt.Sprintf("Thanks for joining this interview session today. I'm %s, nice to meet you. To begin with, let me ask you some questions.", s.substringAfterLastDotOrDash(voiceID))
		fullString := intro + " " + question.Content
		return fullString
	}
	responseToken := responseTokens[rand.Intn(len(responseTokens))]
	transition := transitionSentences[rand.Intn(len(transitionSentences))]
	fullString := responseToken + " " + transition + " " + question.Content
	return fullString
}
